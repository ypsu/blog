<!DOCTYPE html>
<title>notech.ie</title>
<h1>notech.ie</h1>
<ul>
<li><a href="#about">/about</a> contains short intro about this site.</li>
<li><a href="#htmlized">/htmlized</a> contains a link to the html version of this site.</li>
<li><a href="#simulation">/simulation</a> is the answer to the meaning of life.</li>
<li><a href="#uppercase">/uppercase</a> has no reason for its existence.</li>
<li><a href="#autocompletion">/autocompletion</a> just distracts and slows me down.</li>
<li><a href="#history">/history</a> is hard so i do not keep it.</li>
<li><a href="#simplicity">/simplicity</a> makes me happy.</li>
<li><a href="#markup">/markup</a> languages should be simpler.</li>
<li><a href="#gps">/gps</a> just makes the world a worse place.</li>
</ul>

<h2 id="about">about</h2>
<p>
welcome to notech.ie! i noticed that these days i am surrounded with fancy
technology. however over time i thought a lot and realized that that all this
unnecessary technology and general complexity around is making me unhappy. i
became a luddite to keep my sanity. sysadmin at day, technophobic at night. it
is not that i think technology is bad for humanity, i just have a bad personal
relationship with it. i need to vent about this someplace so i bought this
corner of the internet for myself to do so. among other things i loathe html,
css, capital letters so the content on this site is served as plainly as
possible in all lowercase. this way i can avoid dealing with all that baloney
just to jot some thoughts down. if for some reason you want to talk to me, write
an email to flubber at notech.ie.
</p>

<p>
fun fact: this site is available through the gopher protocol as well. if you do
not want to use the browser to read this, just use netcat on a linux:
</p>

<pre>
 nc notech.ie 70 &lt;&lt;&lt; /about
</pre>

<p>
github.com/ypsu/notech hosts the backup and history of this blog.
</p>

<h2 id="htmlized">htmlized</h2>
<p>
the problem with plain text is that it does not really have a standard on how to
rewrap it to other column sizes. i do not mind this, i just assume 80 columns as
the universal width. however that does not play nice with kindle. it wraps
plaintext quite awfully. there is not much it can do with plaintext. it can do a
much better job with html. i quite dislike html but it is a widely used and
supported format so it will do for this purpose. i have the full contents of
this blog available in html at html.notech.ie. i host this on a separate server
(github) because my little server only works for small, &lt;100k files. this
limitation prevents me from creating overly long documents.
</p>

<p>
html.notech.ie contains the whole blog on one large site with minimal formatting
so it is very easy to either open on kindle&apos;s browser or just download and
convert it to a .mobi file. i wish more blogs and sites would allow easy binge
reading.
</p>

<p>
note that i do not limit document width in the generated html because i think
that is rude. making the text narrower is always easier. i can make the browser
window narrower, use firefox&apos;s responsive design mode or its reading view, or
just open the javascript console and enter &quot;document.body.style.width =
&apos;30em&apos;;&quot;. making a document wider needs a phd in css.
</p>

<h2 id="simulation">simulation</h2>
<p>
when i was a little kid, i always wondered where the christmas gifts come from.
people told me that jesus puts all the presents under the christmas tree. since
the gifts were there and i was not a particularly bright person (still not), i
accepted this explanation. they also told me that a god created the world and
that i will live forever in the heaven or hell after i die. but then i noticed
that one of toys i got was not new. so i pestered my parents about it and they
admitted that the gifts do not come from jesus but from them. so then i
questioned people about the rest of the story and most of them admitted that it
is just a story, it is not something that i can verify with my own eyes. i have
to &quot;believe&quot;. ummm. right. i think i will look around first, thanks.
</p>

<p>
so then i read about the people who claim that there is absolutely nothing after
death. there are no supernatural beings, there are no souls. we are just simple
biological meatbags that completely vanish after their expiration. there is not
much point to life other than just to &quot;experience&quot; and &quot;enjoy&quot; it while it
lasts. i will not get another change. there is nothing happening after death,
just like nothing happened before birth.
</p>

<p>
i found this quite an agreeable position. it is quite practical, its explanation
does not seem to require concepts that we cannot experience. however since i
went through one big disillusion before, i was trying to be more open minded
just in case i see even more convincing newer theories. however as i was reading
discussions around the topic, this biological-only camp seemed just as convinced
about their truth as their religious counterparts. i understand that believing
in mystical entities is not practical but flat out stating that things cannot
possibly exist seemed presumptuous. so i kept a &quot;i do not know&quot; stance instead.
</p>

<p>
later i came across the simulation argument. it says that assuming a
civilization can reach the technological point where it can run complex
simulations, it is possible that it has already happened. if one civilization
can reach it then probably many others can too. if that is the case then there
are many simulations running in the world. in fact it is quite likely that most
living organisms are in a simulation, including us.
</p>

<p>
i quite liked this train of thought. it does not try to explain what the world
is, it just a shows one possibility. it just says there we cannot be sure but
there is a chance that this is happening. at this point this did not look any
more practical than the complete denial of supernaturalism but the idea was
nevertheless interesting.
</p>

<p>
so i began thinking about simulations in general. how would i implement them?
how would i play in them? thinking like this opened my eyes. this simulation
assumption actually gives me practical ways on how to approach the &quot;what is the
meaning of life&quot;, &quot;what is the point&quot;, &quot;how should i live my life&quot; sort of
questions. all i need to do is just to apply my thoughts about the
implementation and simulation playing to this simulation (my life). so true or
not, it is practical for me.
</p>

<p>
one could argue that religion is also practical and beneficial. in fact it is
quite likely if we consider it from evolutionary standpoint. there are many
religions in the world. the ones that are overly harmful probably died out and
the ones that survived probably contain many beneficial practices. the problem
is that to pick up a religion&apos;s practices, one also has to pick up its way of
thinking which is usually &quot;stop thinking&quot;. but i quite like some of the ideas
religion has like
</p>

<ul><li>
meetings: regular ritualistic meetings with the same folks helps people avoid
  isolation and folks can keep up with or watch over their community,
</li><li>
rituals: sometimes waking up seems pointless but rituals or habits motivate
  people to not stop living,
</li><li>
festives: rather than keeping every day gray these bring some variety into
  people&apos;s lives,
</li><li>
legends: these build up some folklore, a shared history, something to talk
  about,
</li><li>
afterlife: just something to motivate folks to be good to each other,
</li><li>
fasting: i see more and more articles that this is actually quite beneficial,
</li>
</ul>

<p>
and probably more. however i think all this is achievable without the need to
stop thinking and blindly believing in mystical stories.
</p>

<p>
my foray into the simulation hypothesis will not rise to as mature way of life
as a religion but at least it is based on logic that i agree with. and
eventually little by little i can build up a similarly practical life based on
the observations from this hypothesis. so let me talk aobut what implications i
found from this.
</p>

<p>
the first way i think about the simulation hypothesis is how would i implement
it. there are two main ways to do it: i can make it static or i can make it
interactive.
</p>

<p>
by static simulation i mean something like a movie. the story is given, i can
replay it many times, the same thing happens every time. perhaps i can replay
the same events from a different person&apos;s perspective. i write a story i like
then i can &quot;join and live through&quot; the characters. this assumption leads to
observations like &quot;there is no free will&quot;, &quot;everybody has an importance&quot; or
&quot;there will be a grand ending&quot;.
</p>

<p>
by interactive simulation i mean something like a video game. there is no real
story given. all i have is this big sandbox where everybody is to themselves.
this leads to observations like &quot;there is not much meaning to all of this&quot; or
&quot;just have fun while it lasts&quot;.
</p>

<p>
my personal take on this is that we live in an interactive simulation. i take
this view solely from practical point of view. if the simulation is like a movie
then it does not matter what i do so i might become unmotivated. however if it
is interactive then what i do matters in the long haul.
</p>

<p>
then i also have to think about how complex the simulation can be. if i had to
implement it, i would probably go with the simplest implementation. this means
earth is the only planet in the entire universe with life on it. i would also
make arbitrary constants that make my implementation simpler like limiting the
maximum speed matter or effects can travel so that the supercomputers simulating
all this have an easier time chomping through all the data.
</p>

<p>
the other way to think about all this is to think about why and how would i
participate in the simulation. similarly i can ask why would i want to watch a
movie or why would i want to play a video game. there are usually two primary
reasons to do either of those. i play because i am bored. it is entirely
possible that the outside world is so boring that i am looking for more
fulfillment in the simulation. if i look at it this way, then i am in this for
the fun. just make sure the fun lasts long. alternatively i might be playing the
game or watching the movie because i want to feel challenged and want to feel
that i overcame the challenges. the world is full of challenges. it is up to me
take a chunk of it and complete them.
</p>

<p>
my take is on that i play this because i am bored in the outside world. compare
single and multiplayer games. in single player games there is a challenge i have
to overcome. however if i do not follow the game&apos;s campaign, the game does not
progress. also note that the characters in the game have usually different
roles, each helping me towards the goal or being the challenge i have to
overcome. the single player games usually have a beginning and end. once i
overcome the challenge, the game loses its appeal. on the other hand in
multiplayer games i usually play with other players. most challenges in
multiplayer games would be meaningless without the other players. i play the
game with others, me playing the game makes the game in some sense. most players
have the same roles and the game does not lose its appeal over time as long as
the player base is good. i play this game because it is fun, which means not
playing the game is a more boring activity.
</p>

<p>
the world i observe feels more like the multiplayer game where each player plays
for themselves rather than the single player game where each other entity is
there only for me. this is why i think that i am here out of boredom.
</p>

<p>
my biggest epiphany came when i considered to look at how i watch movies or play
video games. would it be a fun movie if the movie consisted of just other people
watching movies? or would it be fun if the video game consisted of playing other
video games? let me phrase it this way. suppose i want to play a shooter game.
in the shooter game i find an arcade machine on which i can play, say, pacman.
would i play pacman on it? for a few minutes, sure. but would i invest a lot of
time into playing pacman? if i like pacman so much, why not play a game that is
pacman and therefore is probably better designed? why would i invest a large
chunk of resources into a complex simulation in which i play a simpler
simulation?
</p>

<p>
this led me to my first practical observation: watching movies or playing
videogames is silly! to play now and then is fine but i must avoid sinking hours
daily into these activities.
</p>

<p>
and then many other observations started pouring in.
</p>

<p>
if this is a multiplayer game for fun, i should not ruin the game for others. in
fact, it is best if i can improve it for others. i should make the world a
better place to live in. ugh, tough order. but not ruining the game is a good
start.
</p>

<p>
if i am playing a multiplayer game then it is the other players that make the
game fun. it means that i am meant to live among others. i am meant to interact
with others.
</p>

<p>
if i am in this complex simulation with all these rich sensors in my body, i am
probably meant to use them. for instance in person interaction and communication
always feels richer thanks to all these sensors than the low bandwidth messaging
or videochat solutions. messaging is very good for coordination but i should not
use it to maintain long distance relationships. i should build new ones so that
i can the use the rich communication channel again.
</p>

<p>
players come and go. i should not stress too much about particular players. if a
player goes away forever, i shall seek other players to have fun with.
</p>

<p>
i should not stress too much about the past or lost opportunities. i can
probably always respawn and play again if i did not feel fully satisfied.
</p>

<p>
there is no end goal other than being happy. once i reach the point where we can
sustain ourselves with little work indefinitely, i should free up any unneeded
resources we use (e.g. a job) and help others achieve a similar state. with this
hypothesis, it is the other people rather than one&apos;s material possessions that
makes one happy.
</p>

<p>
and i could probably go on. but the general gist is that based on that the
meaning of life for me is to be happy, achieve happiness through personal
relationships, and help others be happy. this is a generally well accepted
meaning to life. but the nice thing about this is that i do not need to blindly
accept this because people in authority told me so. i devised this conclusion
from concepts i am familiar with via reasoning that i agree with. it does not
really matter if simulation hypothesis is true or not, it is a mental tool for
me that helps me make sense of the world. if i cannot understand something in
the world, i can use this tool to ask myself how and why would i implement such
a thing. sometimes things make a little more sense when looked that way. so
therefore my current stance about world is &quot;we probably live in a simulation&quot;
just because it is a practical assumption.
</p>

<h2 id="uppercase">uppercase</h2>
<p>
why are there two glyphs for each english letter? why are there bunch of random
rules to decide which glyph to use in various situations? i honestly have no
idea. i suspect this might have been their history:
</p>

<ul><li>
people chisel into stone tablets. only long straight strokes are practical so
  people use uppercase. only uppercase letters exist at this point.
</li><li>
people start writing with hands. cursive scripts are much easier on the hand
  so people start rounding the letters. eventually these become the lowercase
  letters.
</li><li>
to make books look fancy, the first letter on each page is a huge ass old
  style uppercase letter.
</li><li>
everyone wants to look fancy, everyone makes the first latter old style
  uppercase letter.
</li><li>
now every sentence starts with an uppercase.
</li><li>
now every name starts with an uppercase.
</li><li>
world implodes due to this insanity (not happened yet but soon will).
</li>
</ul>

<p>
this is nonsense. there is zero difference how you pronounce uppercase letters
versus lowercase letters therefore there should not be two separate cases. &quot;oh
but it helps me find the sentence&apos;s start&quot;. boohoo. you will get used to it.
that is why punctuation exists. if uppercase letters would not exist and
somebody would want to invent it, people would laugh them off. say i invent a
middle case with completely different glyphs for each letter and the rule is to
use middle case at the end of sentences or names. does that sound ridiculous?
well, uppercase sounds just as ridiculous to me. most non-western languages do
not have this idiocracy.
</p>

<p>
why keep lowercase instead of uppercase? because lowercase is much easier on
eyes. it has larger variety in height. you see a word like &quot;apple&quot; and you can
see two spikes down before the middle and one spike up after the middle. chances
are you can still better guess the word after applying extreme blur levels
compared to its uppercase version where all letters have the same size.
</p>

<p>
and just imagine how significantly easier writing would become. no more effort
wasted about thinking or discussing the capitalization of titles, names, lists
and so on. less effort typing the uppercase letters. less computer logic to
compare words. if you want to make the world a better place then stop using
uppercase letters. please spread the word to make this revolution reach a
critical mass.
</p>

<h2 id="autocompletion">autocompletion</h2>
<p>
there are two sorts of autocompletion. the first is where the autocompletion
just lists all possible syntaxically correct options, like path completion for
the cd command in bash. the other autocompletion is where a black box tells me
the most likely ending for whatever i am typing. over time i learned to loathe
both.
</p>

<p>
syntax completion is usually quite straightforward, predictable and generally
understood how it works. however it is often flaky and invoking the completion
then choosing the right option takes more time than what it would have taken if
i just typed in the option myself completely. it also allows complexity to stay,
it does not intrinsically motivate me to fix my environment such that
autocompletion is not necessary.
</p>

<p>
let me explain through the path completion example. suppose i have a bash open,
i am in a network file system directory with many files in it. i press tab tab.
now bash has to stat every file and the whole shell just locks up. when the
autocompletion is not instant, it is super annoying. do i just wait longer or
shall i try to kill the botched autocomplete or shall i type further and hope
for the best? all i wanted to spare typing 2 keyspresses and now i am involved
in a complex decision making process. the other issue is when i press
autocomplete too early, i get many choices and now i find myself reading through
all the choices and have to make a choice whether to continue typing or take the
first suggestion. again, in most cases i already know what i want and i could
have finished typing but now instead of doing that i am reading words on the
screen, eating up precious cache space in my small memory. the third problem is
that if i have deeply nested directory hierarchies, i just keep tabbing through
them. i never actually take action to fix them. &quot;it is not so bad&quot; i keep
telling myself.
</p>

<p>
so without syntax or path autocompletion, my editor will never lock up. i will
never need to think about whether to wait for autocompletion or not. no more
pondering whether i should debug or improve the autocompletion or not. no more
contemplation about the ideal autocompletion system. i just type the identifiers
naturally. the screen is not jumping around with random unrelated information
while i type. the only thing appearing is what i typed in, leading to a very
distraction free experience. this is a blessing since have a very easily
distractible personality. the other nice thing is that if i am forced to type in
long identifiers or deep path hierarchies regularly, i will have some motivation
to refactor the environment or structure so that such typing is unnecessary.
basically no autocompletion intrinsically helps me maintain simplicity in my
projects.
</p>

<p>
so these days i do not use any sort autocompletion. i even disabled path
completion in bash. it was very odd at first. but eventually i got used to and i
no longer miss autocompletion. and whenever people are complaining about an
autocompletion failure, i just smirk under my nose, and feel happy that i no
longer have such problems.
</p>

<p>
the other type of autocompletion is this machine learning based &quot;let me finish
what you started&quot; sort of machinery. basically it wants to finish my sentences
instead of letting me do so. i find this very misguided. i take pride that i am
able to formulate full sentences without external help. i do not want help in
writing. i do not use smartphones or other toys so i always have the ability to
comfortably type in any word or sentence i wish. if i do not type the words
myself, i do not learn how to spell them correctly. i am a kinesthetic learner.
if i do not practice something, i do not learn. similarly if the computer
finishes my thoughts, it is much harder for me to think. if i do not need to
think then why am i even here? thinking and formulating full sentences is fun
for me, i do not want computers to take that away. the implementation is usually
also quite distracting. say i start typing a list of keywords i am interested in
and then the search box starts suggesting others. the problem with this is that
sometimes the suggested keyword has absolutely zero relevance to my query, yet i
find it interesting so i am likely to search for that instead of what i
originally wanted. basically the search box is taking away control of my
interests and telling me what to look for instead. i am weak against temptations
so i find it manipulative if things take advantage of this. so i do not want
this either. i made sure that i see no completion on my machine when i use it. i
can think and type for myself, thank you very much.
</p>

<h2 id="history">history</h2>
<p>
tracking every minute detail of my daily failings is pointless. i am talking
about collecting the history of every command i execute in bash, every url i
visit in a browser, or every gps coordinate i ever visited. this is a lot of
data. most of it is just noise. whenever i wanted to look up some data in
history, it actually took very long time browsing through all the data and
sometimes i did not find what i was seeking. i found it is actually more
efficient to reconstruct the command or url from scratch. it also helps me
exercise my memory so it dwindles away slower. i often relied on bash history to
find the right parameterization for a command i remembered using. without
history i cannot do this. but i am better off this way. i am no longer relying
on an external, private, somewhat volatile database to interact with the
computers. it forces me to familiarize with the documentation. if that is
lacking, it motivates me to improve said documentation. better documentation
makes the environment nicer for others too. since i have to type out the
arguments myself, i get more acquainted with the commands themselves from which
i often pick up clever, out of the box ideas. in the urls&apos; case it forces to
learn the url structure of the websites, and to come up with succinct urls for
my own work. sharing urls is very easy and natural when urls are sane.
</p>

<p>
maintaining this history database is also quite the pain. i am not comfortable
keeping my bash, browsing or gps history in some non-personal device or an
external device not encrypted by me. when i use multiple computers, shells,
browsers then maintaining this history becomes quite complicated. i value my
sanity so i would need elaborate bash hacks to keep the history in sync across
computers. perhaps i would consider even more elaborate hacks if i wanted to
inject new history into an already running bash process. or when i use multiple
browsers then they have separate histories and i usually do not remember what
history is in which browser. i could probably set up some sort of elaborate
syncing scheme between them too if i would care enough.
</p>

<p>
the history database might not contain everything. it will not contain entries
from my incognito browsing. i might be remembering that i visited a website,
then i would try to look it up in the history but i will not find there. i would
spend a lot of time before i would realize i used incognito so the history will
not have it. the bash process can also suddenly die and lose precious history in
it which i would then feel bad about.
</p>

<p>
the history does not have good availability guarantees. i might accidentally
truncate all my bash history. i would then feel very sad. or i might decide that
i want to use a different computer and now the history is gone and i have hard
time using it. or if i store my history on a network service, my workflow
depends on that network being available. it is just another unnecessary
dependency.
</p>

<p>
keeping all the history slows down the application. bash now needs to read in
all history before it shows its prompt. not only i have a slower startup, but
now i also have less memory available for other work too. bash and the browsers
need to keep some history in the memory too to keep lookups fast. and in bash&apos;s
case it probably does not even share history between the processes so i would be
paying this cost multiple times.
</p>

<p>
the history might have chance of leaking. suppose somebody sits down to my
computer and starts browsing. now they could easily see all my naughty sites i
visit or the naughty data i have. if it is on a networked service, then there is
a chance that there will be a global leak at some point and then everybody will
have access to everybody else&apos;s history. that might contain some things i would
not be comfortable with others seeing.
</p>

<p>
and do not even get me started on the idea of tracking gps location history.
that is wrong on so many levels that i will not even bother trying to explain
it. i do not use gps nor smartphones so i do not have this problem. but i
suspect smartphones have this feature enabled by default. it is just something
to be aware of. i understand that my carrier probably tracks my brick phone&apos;s
whereabouts but at least i do not have to worry that 7 independent services also
tracking it via their preinstalled spyware.
</p>

<p>
so i stopped caring about my tracking my history. i find that this leads to much
healthier practices, better memory, less work and less worrying about losing or
leaking said history. therefore i disabled history where i could: bash and the
browsers. note that i still keep per session history in bash because otherwise
correcting typos in commands would be super annoying. but i never write out the
history to disk. i actually use a raspberry pi as my primary hobby computer so i
get less wear on my sd disks this way which is a nice plus. besides, forgetting
is a feature. if i forget something, then 99% of the cases it is a good
riddance. no need to carry on the past forever.
</p>

<h2 id="simplicity">simplicity</h2>
<p>
i really dislike maintaining and debugging complex systems. i suspect nobody
likes them. yet no matter how hard people try, we always end up in a mess.
however i do not think this has to be the case. we should be able to create
simple systems. all we need is a set of healthy practices and an agreement from
all parties participating in the system that we want to avoid ending up in a
complex system. everything starts simple but it is actually quite hard to keep a
system simple especially if said system grows in number of features, components
or participants. but here is one of the key observations: growth is what starts
making systems complex. usually growth results in weird new interactions between
the system&apos;s components. the system&apos;s original design might not be a good fit
for the new, larger usecase.
</p>

<p>
so here is the key lesson from that observation. if everything starts out simple
but then growth makes systems complex then all we need to do is stop the growth.
easier said than done. this is especially hard if the sole goal of our system is
to replace other more complex systems. but if we allow growth, our system will
grow into the same complex system we were trying to replace. my take from this
is that we ought not to replace existing systems with new systems entirely. in
fact the new system should explicitly forbid to grow into the same proportions
as the larger system.
</p>

<p>
one way to achieve growth limitation is to set explicit limits for the features
in the system. when a limit is reached then do not just bump the limit but
either move the misfit component out of the system or restructure said component
so that it works in the system. growth in such a system is going to be super
frustrating. but it is that growth that the system is set up to prevent. people
usually do not like systems that make them frustrated so such system cannot
become a popular system. that is the downside. on the other hand the
participants who accept the limits willingly will stay happy because they will
not get bogged down with all the unnecessary complexity.
</p>

<p>
allow me to demonstrate these concepts with an example. my ideal computing
environment is where every component of the stack from the operating system to
all the user space applications is super simple, easily understandable,
reviewable, perhaps tweakable. this environment might not as efficient as a hand
optimized mainstream stack but i would not mind that because i can then
understand my tools with less expertise. it would be easier to customize the
system to my usecase.
</p>

<p>
one component of this stack would be the text editor. i could decide on its
implementation. i could use fancy linked lists to manipulate large chunks of
text efficiently. or i could impose terrible limits on my text. i could say this
editor will not support lines longer than 100 columns and 10_000 lines. such
draconian limits would significantly simplify the implementation because i will
no longer need to think about efficient ways to handle large files or files with
long lines. using such editor will be quite terrible too. most people would hate
these arbitrary limitations. i would not mind though. i suspect there would be a
handful of other people who would also embrace this. first of all, people can
get used to limitations. early computers had tiny amounts of memory, yet most
things still worked out finely. secondly, if my system has an arbitrary limit of
100 columns per line, then writing other tools are much easier too. they do not
need to have complex logic to handle arbitrary length strings or concern about
algorithms that do not scale well to long strings. the simplicity of this
arbitrary constraint cascades through the whole system.
</p>

<p>
arbitrary limits or constraints are not only useful to keep the system simple.
they force me to become creative. suppose i am writing some complex software. i
keep writing the whole shebang into one file and after some time i reach the
10_000 line mark. on a contemporary system i do not even notice that this
happened. however in this limited system i suddenly become painfully aware that
i hit the system&apos;s limit. i am now forced to step back and perhaps split my
project into smaller modules at that stage. at that line count that is probably
a good idea anyways. so the constraints keep me on my toes and keep my activity
in check. these constraints are not just something to keep some parts of the
system&apos;s implementation easy but also to signal to the system&apos;s components what
are the expected behavior and resource usage they have to work with. keeping the
overall system simple is not something to graze over though. it is no
coincidence that even these days people still make commodore or amiga demos just
because working in a limited, fully learnable environment is so refreshing.
</p>

<p>
but note that if i am paid to write software for others, i am often not terribly
excited about the projects i am supposed to do. if i run into some frustration
stemming from arbitrary constraints of a tool, i might be tempted to simply
switch to a tool that does not have said limitation. the resource costs,
inefficiencies, the bugs of that tool or the complexity debt i add due to using
a more complex tool is not my problem, my employer can pay others to deal with
it. and this is actually nice because this way my employer can pay others to
make faster and larger computer chips or ready software bundled with many
features and thus the world does not stop progressing. though note that if i am
solely on the hook for said tool then i would start looking into refactoring my
use of the tool instead.
</p>

<p>
however in my hobby environment i really the idea of simplicity stemming from a
constrained environment. so when i am writing my little tools in c i do not shy
away from just using a few large arrays and returning an error if i try to use
them on a larger input. this way they do not become slower over time as the
input grows unboundedly. i know the input limits at the time of writing so every
decision i made in its code is based on that assumption. if the input outgrows
my tool, i usually need to rearchitect my tool anyways. i usually do not know in
which dimension will my tool grow. does my text editor need to handle longer
lines or more lines? making the tool scale in every dimension makes its code
super complicated. at first i will assume no scalability and then if the need
really arises, i might think a little bit about it.
</p>

<p>
it is not just my computing environment i like simplicity and predictability.
this is also why i do not own a smartphone. it is such a complicated device. but
everything can be done on a desktop computer too. with a desktop computer i am
physically constrained to be in front of the computer to use it. i actually like
this constraint otherwise i might just keep checking my smartphone all the time,
even when i would be better off just looking at the nature or listen to the
chatter of others. another example would be the fact that i very much dislike
spending money which has many ramifications. for instance i try to avoid
spending money on transportation and therefore i walk everywhere if i can. at
the time of writing this my commute to work takes 1 hour by walking. this
arbitrary constraint of being a cheapskate actually keeps me somewhat fit and
gives me 2 hours daily just to meditate and think things through. my life gets
simpler and i actually feel happier because of the workarounds i need to do due
to these voluntary limitations. and this is why i like voluntary constraints.
</p>

<h2 id="markup">markup</h2>
<p>
i hate most markup languages because of their feature creep. it all started with
html. it is the most popular markup language since most web is in that format. i
am not sure if it was ever meant for humans to write though. probably not.
however it is not so bad if you do so and only use the basic features. but most
sites i visit generate their html from other sources of truth so browsing the
internet without a html parser is impossible. this is quite sad though. i think
its original goal was to mark up plaintext document with &quot;links&quot; and that is why
it was called hypertext markup language. and while at it they added some extra
markup to separate individual paragraphs and to insert headings, emphasis,
simple lists, tables and images. then based on the capabilities and the settings
of the client&apos;s computer, a browser rendered the document as nice as it could.
</p>

<p>
but html today is not what it used to be. i do not consider it as a markup
language anymore. i consider it as a file format to render resizable &quot;content&quot;
in a browser. it is a programming language. as such i am no longer in control
how the computer renders the document for me. even worse, some sites go as
moronic as to use their own crappy font from the internet rather than the fonts
i specifically set. i have preference for specific fonts and i prefer to read in
those. or set a maximum width for their document. have these people not
considered that there exist people on this planet that are able to read more
than 2 words per line? making lines shorter is easy since i can just make the
browser window smaller or go into the browser&apos;s reader mode. making lines longer
is much trickier. oh, i could disable css. but then often the document becomes
tangled in the sense that all the content and non-content bits are interspersed
in one giant blob of text. website owners really should really consider ensuring
that their site still works without css and javascript. basically make sure the
site is browsable in the links terminal browser.
</p>

<p>
on the other hand crappy site usually also means crappy content. so if the site
tries to force a specific &quot;viewing experience&quot; then chances are it is trying to
compensate for low quality content that i would not really want to read if it
were to presented in, say, plaintext format. therefore i rather avoid such
websites. visiting fancy websites actually reminds me that i probably should be
doing something better instead. so thanks for doing that.
</p>

<p>
the other markup popular markup language is markdown. it started out simple and
with the explicit goal that the plaintext version of the document remains just
as readable. it added a little bit too many features in my opinion though. but
that would not have been too much of a problem had it stayed that way. but when
i look at the newest versions it is utterly nonsensical. for instance i open the
commonmark&apos;s specification and i am presented gazillions of features and then
long discussion about all the corner cases of those misdesigned features. and i
suspect it will get much worse over time. when a person starts using all those
fancy features it is again a smell that the author is spending way too much time
on the presentation which suggest that the underlying content might not be as
interesting as they wanted it to be.
</p>

<p>
really there should be only a handful of features needed. all the markup
language for simple documents is supposed to do is to make it resizeable so the
readers can read it on various devices with various font sizes. here is the list
of features that ought to be enough for everyone:
</p>

<ul><li>
headings: this allows generating table of contents and allows creating anchors
  for specific sections. no more than 2 levels though excluding the document&apos;s
  title.
</li><li>
lists: either ordered or unordered. lists are handy organization tool. usually
  people prefer the text to be indented so that it is easy to skip to the next
  entry in the list visually. this changes the resizing logic a little bit and
  this is why needs to be a first class element.
</li><li>
preformatted content: this section would look exactly the same in the rendered
  document as it looks in the source with monospace fonts. very handy for tables
  or code blocks. usually this is only needed in technical documents. most text
  would be fine without this.
</li>
</ul>

<p>
and this is all what is needed. stop at that and i am happy. those features are
quite straightforward to implement and do not have corner cases. in fact this
website is written in a markup language that only uses those features. look at
my /htmlize article to see how this site gets transformed into a nice html page
in a few lines of awk code. it does not support headings though because i just
use different files to organize different sections. the generator creates the
headings based on the filenames.
</p>

<p>
and here is what is not needed in a markup language for simple documents:
</p>

<ul><li>
hard line breaks: just use lists or preformatted content.
</li><li>
emphasis: just use punctuation marks like quotes to emphasize a word or
  sentence. as with all practices, once you get used to this, you will not miss
  the italics.
</li><li>
bold, underline: these create a very jarring effect on the text. bolded words
  pulls my eyes towards themselves and that makes reading the surrounding text
  harder. please do not make your text harder to read.
</li><li>
tables: there is no nice way to express this. just use the preformatted
  content for tables. if you have trouble editing tables in plaintext then
  either simplify your tables or use a text editor which can edit plaintext
  tables.
</li><li>
paragraphs in lists: if your content in the list is so long that you need
  several paraphraphs then it is best that you do not organize the content into
  lists but into paragraphs.
</li><li>
lists in lists: please avoid doing this. nested structures are quite hard to
  follow. just be creative and organize differently. use preformatted content if
  you really need a specific structure.
</li><li>
links: i do not like the fact when the document tries to hide what it is
  pointing at. i much prefer to see the naked links. so just write out the link
  in its entirety. then the document renderer can decide to render these bits as
  links. the markup language does not need any special support for this. this
  also requires for the writer to simplify the link so that it remains short and
  sweet. short links help the reader understand where the link points to. but do
  not use url shortening services, that is cheating. in general, avoid writing
  in a way that requires links or even footnotes. it makes reading much harder
  because the reader is now tempted to check out the link rather than just
  simply continue reading. i am very easily distracted so reading a document
  with many links or footnotes ruins the experience. just have a &quot;further
  references&quot; section at the end of the document for the links with a short
  summary what each link is about.
</li><li>
footnotes: footnotes are quite distracting because of the temptation of
  checking them out and then navigating back and forth in the document. but in
  some cases they are unavoidable, like in wikipedia&apos;s case where you want to
  reference the source of all claims. however these do not really need to part
  of the markup either. you can just use, say, bracketed identifiers like
  [myref] and then have a references section at the end of the document which
  expand these references. the document renderer does not need to add support
  for this either. if you are curious about a reference, you can just search for
  &quot;[myref]&quot; in the reference section and you can read it. in fact to do not make
  navigating references easier than that because otherwise writers are tempted
  to use them to add interesting footnotes rather than incorporating those bits
  into the main document. for footnotes i recommend using parenthetical comments
  instead.
</li><li>
blockquotes: just use quotation marks. if you have a longer section that you
  want to indent, you can always a single element long list. it is a bit weird
  but just as effective and simplifies both the format and renderer because they
  do not have to support yet another feature.
</li><li>
images: most documents do not need images. but sometimes an image indeed adds
  a lot of value to a document. in plaintext all you can do is to provide a link
  to the image. so you can use that. maybe i would accept a notation where you
  prepend the url with a &quot;!&quot; to signify that the renderer should inline the
  image. but never use this to embed videos or gifs. only add static images. i
  am incapable of reading text if there is any movement on my screen.
</li><li>
scripts: if your document needs scripts then it is not really a plain document
  but rather a tool or an application. probably it is not meant for simple
  consumption but interaction. e.g. if you add some sharing or commenting widget
  then you are probably not trying to teach or entertain people but rather you
  are trying to garner some reaction and perhaps sell something. you are in some
  shady business then. people should probably avoid your document. if you are
  considering enabling comments then it is better to go to online forums and
  make your posts there instead. such places are better suited for discussions.
  or just have your readers send feedback privately. then you can do a summary
  post with the feedback and your response integrated into the text. the quality
  of your site remains higher and your readers have an easier way to keep up
  with you.
</li>
</ul>

<p>
if somebody has something interesting to say, they do not need formatting. they
can just tell it plainly. if a text is trying to explain a complex concept,
fancy formatting will not make it easier. it will just give it an appearance of
simplicity but not actually help. i recommend improving the text instead so that
it explains the concept more vividly or with more examples.
</p>

<p>
as for my markup the rules are simple. the document is considered in paragraphs
where paragraphs are separated with empty lines. the paragraph&apos;s first line
determines what sort of paragraph it will be. if it begins with space, i wrap
the whole thing into a &lt;pre&gt;. if it begins with a &quot;- &quot;, i treat is as an
unordered list and each line starting with &quot;- &quot; starts another element.
similarly with &quot;[0-9]*. &quot; begins an ordered paragraph. if none of the above
matches, i wrap the paragraph into an ordinary &lt;p&gt; tag. and that is all there
is. no corner cases, no complicated implementation needed. if i cannot express
something with the above rules then that just means i am not challenging myself
enough. i then go and think hard and come up with a way that can fit those
rules. the result is then much simpler and i am then usually more pleased with
it and thus i am happier. so simple rules lead to better documents.
</p>

<p>
example in case you are viewing this in the html version:
</p>

<pre>
 test paragraph
</pre>

<pre>
 - unordered list
   with multiple lines
 - and entries
</pre>

<pre>
 1. numbered list
 2. entry two
</pre>

<pre>
  pre
     formatted
               content
</pre>

<p>
gets translated to this:
</p>

<p>
test paragraph
</p>

<ul><li>
unordered list
  with multiple lines
</li><li>
and entries
</li>
</ul>

<ol><li>
numbered list
</li><li>
entry two
</li>
</ol>

<pre>
 pre
    formatted
              content
</pre>

<p>
and that demonstrated all the features i need and support.
</p>

<h2 id="gps">gps</h2>
<p>
the global positioning system is a marvel of human engineering, no doubt at
that. however i really wish it would not exist. my personal beef with the gps is
sucks the fun out of the exploration. i owned a smartphone for about a year
before i threw it away so i do have some experience with gps and navigation. in
those days whenever i wanted to go to any place, i just simply put in the
destination into the device and then followed the path it devised. rather than
looking up and learning about my environment, i was looking down to my phone,
following the arrow and only looked up occasionally to check which street i have
to turn onto. basically i felt that my phone reduced me to a mindless drone. i
was completely fine before the gps, never felt that i was missing it but after
the phone ditch event i felt some withdrawal effect from it. i was even a bit
afraid to venture outside just because i might get lost. however i feel much
happier without it. whenever i want to go to a place i have not been yet, i have
to plan ahead. i have to study the map. i have to learn about large landmarks
that can guide my path. i can perhaps walk through the path virtually through a
street view application. i even draw myself a minimap just in case i do not
remember all the details. then i can execute the journey. during the journey i
am very attentive to my environment. i am sort of in the csíkszentmihályi like
flow where my mind is quietly alert and focused on one thing. i am also very
confident because i know what i expect at every corner. and when i successfully
get to my journey i am quite happy that i planned well and managed to execute
that plan successfully. or maybe i feel happy because of the flow state i was in
for long time. so having no gps, makes my life more fun.
</p>

<p>
okay so i do not need gps but then why do i say it should not even exist? my
problem is that i do know that it is very easy to get hooked on it. once hooked
it is very hard to imagine life without it. people will forget that there are
others who do not have access to gps devices. they will not learn to give
directions in an effective way. they will not create landmarks that simplify
navigation. so my problem is that if society gets overly dependent on gps then
that society will be harder to navigate through without the gps because there
will be no intrinsic motivation to make it simple. basically it will make the
towns and other places less accessible.
</p>

<p>
it even ruins videogames. when i play an open world game, it usually has some
sort of waypoint system so i am just reduced to mindlessly following the
waypoint there too. i do not even look at all the nice scenes the game artists
created for me to enjoy. there is no exploration required. sure, i could turn
off the navigation system but then the game becomes unplayable because the
quests in the game do not fully explain the destination and often there is no
good way to look up a route to the destination and then following that route
without constantly checking the minimap if i am at the place i am supposed to be
or not. this is the effect i was talking about: if people assume that gps
exists, they will not make the place accessible for non-gps users.
</p>

<p>
what i would really wish instead that we would make navigating the world so
simple that a gps is just not needed. suppose a city is organized into a grid of
roads and all the roads are just numbered sequentially. such city would be
boring. but navigating would be super simple because you only need two numbers
to specify a location in it. you can get to that location from any given
location without a map. we should have more like that. so whenever you are
coming up with organization scheme for physical space, try to come up with a way
that does not require navigation tools. make it boring. boring structures make
me happy. please make me happy.
</p>

<p>
and the other problem with universal gps access is the privacy violations it
leads to. large organizations or family might want to know where each member is
at any given moment which usually does not lead to trusting relationships. it is
a silly idea at this point but as technology proliferates it might become more
and more accepted. i might only want to track track my children at first for
their own &quot;safety&quot;. when i fully make terms with that arrangement, i start
thinking of tracking a spouse for their &quot;safety&quot;. then when i get terms with
that arrangement, i might want start tracking more and more family members and
so they want track me in exchange. now everybody is tracking everybody&apos;s
movements. then when governments want to track me for my own own &quot;safety&quot;, i
might not be objecting to it because it is now &quot;normal&quot; to track people. the
situation is horrible at this point. the whole thing escalates in baby steps. it
is better to stop the whole thing in its roots and just live in a way that does
not require the knowledge of one&apos;s position on this planet.
</p>
