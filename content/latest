<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>notech.ie</title>
</head><body>
<h1>notech.ie</h1>
<ul>
<li><a href="#complexity">/complexity</a> in software can be avoided.</li>
<li><a href="#pain">/pain</a> is something to embrace.</li>
<li><a href="#thecook">/thecook</a> short story.</li>
<li><a href="#xgeec">/xgeec</a> is another silly site idea i would like to see existing.</li>
</ul>

<h2 id="complexity">complexity</h2>
<p>
everybody hates complexity. yet at the same time msdp (&quot;modern software
development practices&quot;):
</p>

<ul><li>
  encourage adding complexity under the disguise of reducing complexity.
</li><li>
  discourage people from gaining the expertise to avoid complexity.
</li>
</ul>

<p>
it is not done purposefully. complexity is painful. people do not want to
experience pain. so as long as people do not feel pain things are good. msdp are
like painkillers. they definitely do help not feeling the pain of complexity, no
argument there. but just because people do not feel it, it does not mean it is
not there. eventually people get so much painkiller into their system that they
cannot live without it anymore. and the eventual consequence of all this is
mental breakdown or burnout.
</p>

<p>
all software is a solution to a problem rather than an end in itself. what is a
&quot;problem&quot;? problem is a pair of states: input state and output state. there are
many sorts of problems:
</p>

<ul><li>
  i have a list of numbers -&gt; i have the average of those.
</li><li>
  i have an essay in a text file -&gt; i have the most common word of the essay.
</li><li>
  i time to kill -&gt; i am watching a video.
</li><li>
  i want to pay for the pizza -&gt; the pizzeria has my money.
</li><li>
  i am craving sugar -&gt; i have ice cream in my hand.
</li>
</ul>

<p>
software is that tiny &quot;-&gt;&quot; bit between the two states. in fact, the software
part is completely irrelevant! yet for complexity reduction msdp focus on that
tiny irrelevant part. this is what happens when people consider the software as
an end in itself. the focus should be on the problems instead.
</p>

<p>
take the first problem. it is quite abstract but for a programmer it is super
clear what it means. one can even mentally fill how the software works because
it is just that obvious. now take the last problem. it is very fuzzy and
subjective. it is unclear what the software will be between them. do we create
an online shop where people enter their feelings and we send the appropriate
item for said feeling? or do we create a software for mixing ice cream based on
how much sugar the human wants? it is super unclear what are we trying to solve
here. usually this fact does not stop people from firing up their editor and
start furiously developing stuff.
</p>

<p>
what is the difference between the two problems? the first one expresses a
problem via well known computer science terms: numbers, strings, lists. the last
problem expresses it via abstract terms that try to clearly identify the
concepts in question.
</p>

<p>
why is the software trivial in the first case, complex in the latter? in the
first case the two states are very objective. everybody agrees on what the two
states mean and can reliably tell what and what not matches those descriptions.
as such when people think how to solve the problem, they pretty much arrive at
the same solution so there are not many creative differences in its software
development process. in the latter case people cannot fully agree what
&quot;craving&quot;, &quot;ice cream&quot; or &quot;in my hand&quot; means. every person will have a different
understanding. they will have different assumptions. they will want to implement
different things. and in the middle of the development process they realize that
one team meant something completely different for &quot;in my hand&quot; than the other
team and now they are creating even more problems and software to bridge this
misunderstanding.
</p>

<p>
what is the solution? the job of the software engineer is to reduce the
subjective states into the objective realm of numbers, strings and lists.
</p>

<p>
what does msdp recommend? numbers, strings and lists are unintuitive and hard,
we should abstract and create new terms. instead of &quot;list of numbers&quot; you have
&quot;grades&quot; of &quot;students&quot;. instead of &quot;average&quot; you have &quot;grade average&quot;. when you
define things like this, they start getting muddy. what is a grade? is it a
number? is it a letter? what is the grade average of &quot;a a a b&quot;? the more
abstract terms one introduces, the more muddy the problem and its software will
be. this is what i meant under &quot;msdp encourage adding complexity&quot;.
</p>

<p>
and to top it off, all the tooling msdp create are further exacerbate the
problem. it is all about object orientation, genericity and even type hiding so
that you have even less chance to understand what is going on. people are having
harder and harder time to communicate with each other just because of the sheer
amount of unclear concepts one has to hold in their head.
</p>

<p>
following this practice leads to very very long problem descriptions with many
many types of lists, strings and numbers for the various aspects of the problem.
yes. but the key observation here is that if you write all this out, then you
will see the problem&apos;s essential complexity in its natural form. it will be
ugly. it will be painful. but just because something is ugly or painful, does
not mean you should hide it. what you need to do is to learn to not mind that
ugliness. keep working with it and over time you will gain all the necessary
experience to spot and mentally chunk patterns just like professional chess
players can take a quick look at a chessboard and instantly understand the full
state (and if not then they know that things are messy and should be cleaned
up). if you are a doctor then it would be a quite weird if you would be
uncomfortable looking at dicks. no, instead the expectation would be that you
learn a lot about dicks so that you can look at any dick without problems
because that is the human body in its natural form. yet msdp recommend that you
do your best to hide all those dicks so that nobody gets uncomfortable. the
developer novices do not even have the chance to learn to recognize patterns.
they must work with new abstractions all the time. and if they break down
something too much, they are scolded that they are not following msdp. this is
what i meant by &quot;msdp discourage people from gaining expertise&quot;.
</p>

<p>
the next important task after breaking down the problem into numbers, strings
and lists is to document the mapping between the subjective and the objective
representations of the problem. even though msdp recommend doing this with all
that object oriented madness, this cannot be done formally. the only way to do
this is by writing informal prose. the writer of such mapping must meticulously
explain what each number and list represent in the subjective world. in other
words a software developer&apos;s task is not really to write software but to write
text!
</p>

<p>
this is no easy task. and why would people bother writing documentation anyways.
all the structure is super clear in their mind so the mapping between the
subjective and objective world should be super clear to everyone else too.
interestingly when most developers look back to their own code written in the
past, they think it is ugly and unnecessarily complex. in such cases the
assumption is that this is because they got smarter but that is not the case.
they would write the same code today too. the only thing they are lacking is the
context of their code. and the reason they lack it is because they did not
clearly document the input and output in simple terms. the other characteristic
of most developers is the feeling that they should refactor all the time. they
write something and they are very proud of it. then they try to actually extend
it they realize that what they wrote is not any good and they want to start from
scratch. they constantly want to reimplement things. as such their productivity
is pretty low. if you are thinking in terms of input and output then
understanding code is not hard and you do not get the feeling that your old code
is bad nor do you feel the inclination to refactor all the time.
</p>

<p>
suppose you are using linux every day. you get curious about the kernel. you
want to learn more. you download and open its source code. you barf. it looks
unnecessarily complex and think this is crazy. you even think maybe you should
write a new operating system from scratch just to show them how is it done. see
the problem? this is the &quot;software as an end in itself&quot; approach. if you open a
piece of code and say &quot;i want to understand this&quot; then you are doing it wrong.
</p>

<p>
what you need instead is a problem. you could say &quot;i have all these processes; i
want to know how can they run simultaneously&quot;. if you phrase it like this then
your first step is not to download the linux kernel source code and get
frustrated about its complexity. instead you first open the wikipedia and start
learning about processes. if you know everything about them then you start
learning about the schedulers. once you know about those, you start searching
about linux specific schedulers and you learn how do they work. at no point did
you need to open the linux kernel source to answer your curiosity. but suppose
no one is around to tell you what linux is doing. then you must download and
inspect the code. however in this case you already have the context: you know
the technical terms around both processes and schedulers. you know that you are
looking for a specific thing. you also know that this is a very core thing in an
operating system so &quot;drivers&quot; will not be the right directory. you can pretty
much tell what does and what does not look relevant to this. you find the
corresponding file and it tells you the name of the scheduler and even points to
docs. you got your curiosity satisfied without any complexity getting into your
way. all you really needed is to get accustomed to some objective terms and
concepts and then understand the problem in those terms.
</p>

<p>
software does not exist in vacuum though. it is used in a domain. if the domain
has well specified, objective terms for concepts, then using those when reducing
problems is fine. in the domain of computer system administration i work with
the following concepts:
</p>

<ul><li>
  files: contain all the data.
</li><li>
  processes: calculate all the data.
</li><li>
  rpcs: remote procedure calls for communication.
</li><li>
  machines: run the processes.
</li><li>
  users: isolate or limit the processes.
</li>
</ul>

<p>
if a state is expressed in these terms then i can probably understand it pretty
quickly. it is very easy for me to &quot;visualize&quot; the state in my mind. when i
visualize both the input and output state, i can sort of get a &quot;feel&quot; for what
is happening in between. if i start seeing &quot;tasks&quot;, &quot;channels&quot;, &quot;configs&quot;,
&quot;objects&quot; then things start getting muddy for me. people try to be nice and
&quot;hide the complexity&quot; but all it achieves that i am no longer able to see all
the pieces the software is working with. all i see is fog.
</p>

<p>
it might seem that some problems cannot be reduced to such simple terms. e.g. i
want to write a videogame but i do not really know what exactly the end result
will be since it will require a lot of iterations to get everything right. even
so, you still have a rough idea what you want. in a shooter you want a 3d
environment, players, enemies, weapons. you can break down those concepts into
their corresponding data structures, find some common problems that you are sure
you will encounter (moving around, collision detection), implement those, and
then go from there. the idea is that you should have a clear, objective mapping
between the concepts and their data representation in simple types.
</p>

<p>
another reason people are afraid of deconstructing things into their base forms
is that if they write out the full state like that in such simplistic terms then
it will be way too long and unhelpful. however length should not be an indicator
that you need an abstraction but rather that you need to think more to come up
with a simpler system. sometimes this is impossible: you want efficiency or good
usability and for that you need all those pieces. that is okay. in such case it
will be clear that we are trading simplicity for features. it will be also clear
when are we having way too much features and maybe start thinking in different
terms of approaching the problem.
</p>

<p>
take the case of long functions. msdp suggest that you should break down long
functions if it makes sense. this then reduces the number of local variables you
need and thus you reduce the state the &quot;poor reader&quot; has to keep in head. but
that makes no sense if you consider things from the input output perspective.
you are not reading a function for entertainment. if you are reading a function
then that means you are either trying to extend it or you are trying to find a
bug in it. in both cases what you really need is a good understanding of what
the function does. if all you see is just invocations to other opaque functions
then it will not be clearer what is happening. what you really need is a human
telling you what the function does in high level terms. when you have that
understanding, then you will also have a feeling where to put the missing piece
or where the faulty line might be. where are you going to get this if you do not
see any human around? you will get this from the comments. in other words what
you are really looking for are human comments in functions. and you need good
quality comments. how do you get that?
</p>

<p>
there is this phenomenon in in-person human communication: suppose someone is
explaining something to you. when they finish the explanation, they are looking
at you, waiting for a reaction. if you do not provide any reaction, the other
person will assume that you lost the thread and they will start explaining in
more detail. this also works with code! if you write a large chunk of code then
you will feel bad if you do not give a summary commentary in front of the chunk.
however small chunks feel obvious and as such they are left undocumented. if you
split up a large functions into many small functions, it is pretty much expected
that you will have less documentation and your code will be much harder to
understand.
</p>

<p>
good rule is this: when you see the same logic in 3 places then consider
factoring them into a function but no sooner. below 3 you simply do not know if
the abstraction you are creating is good. 3 and above it means that there is a
common concept hiding there, it might worth naming it. this process is called
semantic compression. note that this process applies when deconstructing state
too: if there are common structures (4 floats representing a vector) then it is
okay to define a structure for them (struct vector). but this structure is just
for naming a common concept, it is not meant to hide its elements or assign
functionality to them like you would do in object oriented programming.
</p>

<p>
since poor functions are one big source of complexity, let me elaborate a bit
further on them. you should treat a long function like you would treat a book.
it should start with an introduction what the function is about, what the inputs
and outputs are and then a table of contents of its logic for quick navigation.
do not use numbers for the sections because the numbers might get invalidated
quickly. make sure the heading names are unique so that the reader can quickly
navigate by text search. this does not really look nice in small examples but as
a quick demo a small example will do:
</p>

<pre>
 // return a solution to a^2*x + b*x + c = 0 (unspecified which one in case of
 // multiple results). x is an output-only variable (must be non-null). the
 // function returns true on success, false in case there is no solution.
 bool solvequadeq(double *x, double a, double b, double c) {
   // solve the equation using the following steps:
   // basecases: handle the base case.
   // discsqrt: calculate the square root of the discriminant.
   // returnres: calculate x and return it.
</pre>

<pre>
   // basecases: handle the base case.
   if (a == 0) {
     *x = -c / b;
     return true;
   }
</pre>

<pre>
   // discsqrt: calculate the square root of the discriminant. this platform
   // lacks sqrt so we implement our own approximation via newton&apos;s method.
   double disc = b * b - 4 * a * c;
   if (disc &lt; 0) return false;
   double discroot = 1;
   for (int i = 0; i &lt; 20; i++) {
     discroot = discroot - ((discroot * discroot) - disc) / (2 * discroot);
   }
</pre>

<pre>
   // returnres: calculate x and return it.
   *x = -b + discroot / (2 * a);
   return true;
 }
</pre>

<p>
as you can see i inlined a sqrt (with the assumption that sqrt() was not
available). sqrt is a pretty well known and understood concept so it would be
okay to grant its own function. but there was nothing of value lost by just
simply inlining it given that it is only used from one place. you could argue
that this way somebody might add another sqrt or that when the platform gets its
sqrt support, nobody will replace this piece of code. now this might be true for
simplistic example, but for a more complicated example somebody would totally
reimplement frobnicate() even if a frobnicate() would have existed already (they
would call it dofrobnicate() so the compiler cannot point out this mistake to
them). and the second concern is not addressed by decomposition either. you will
still have identical pieces of code all around. and even if msdp would address
the issue of duplication, it is a moot point. remember, complexity does not stem
from duplication. complexity stems from the fact the concepts the code works
with are subjective and unclear. obsessing about duplication will not reduce the
complexity.
</p>

<p>
by the way, another trait of msdp is that they always demonstrate their points
using simple examples and for that they all seem convincing. demonstrating
complex examples is cumbersome so they never get to the point where they would
see their systems crumbling down under their own self-inflicted complexity.
</p>

<p>
some comments look superfluous in this small example just like having too many
subheadings in a small book is superfluous. i would not give this many comments
for a function like this. but for longer functions they can really help the
navigation. free form comments are much easier to read than
handle_the_base_case(). from such function name you do not know that it is
related to quadratic equations even.
</p>

<p>
if you squint enough, this is very similar to knuth&apos;s literate programming. the
difference is that in this case we do not generate a separate document for
consumption.
</p>

<p>
what would happen if you started breaking down a long function into short
functions and/or approach the problem in an object oriented programming way? the
essential complexity would still be present, you cannot eliminate that. however
it would add a lot of accidental complexity. you will get bunch of new problems.
you have to pass around state. things will look quite okay initially but it will
be a maintenance and debugging nightmare. when requirements change and you have
to tweak some functionality here and there, you will realize that you need to
pass around even more state. your function prototypes start growing bulky (and
the function names will be obsolete just as well as comments can become
obsolete). eventually you will end up in a codebase where the function splitting
look pretty much arbitrary and does not make any sense. or suppose you want to
speed up the above function. when you look at it like this, it is pretty obvious
that you can trade speed for accuracy just by decreasing the number of
iterations in the loop. you have immediately seen that. had everything been
abstracted away, such observation would have taken quite a while to arrive at.
or suppose you are trying to debug this function. you want to add print
statements here and there to dump state. if all state is available in this
single function, adding such print statements at a few tactical places is super
easy. doing the same in a heavily abstracted code is painful. the point if you
have a lot of abstractions then you spend a lot of time fighting against those
abstractions and this fighting is called the accidental complexity. this is why
all those abstraction fanboys want to refactor their codebase all the time. you
can avoid all this pain just by not abstracting at all until there is a clear,
objective benefit to it (you have at least 3 cases that you can replace with a
single concept).
</p>

<p>
another observation of the whole input output approach is that if the code does
not matter, then the choice of platform and programming language does not matter
much either. this is one of the reasons why c got very popular. it was not
trying push any methodology on people (other than the const correctness
nonsense). it implemented the basic features that people needed for structured
programming and it turned out that was enough for almost everything so it spread
like a virus.
</p>

<p>
this is getting already way too long so let me wrap up. if you disagree
everything written in this post, i ask you this: there are people who manage
complexity like this and it works really well for them. give them some space. do
not disregard their approach completely just because you do not agree. if
something is unclear when approached like this, just ask for better comments.
</p>

<h2 id="pain">pain</h2>
<p>
pain is a signaling system. it signals that something is not right. there are
two types of pain: sudden spike and chronic pain. if you suddenly feel pain then
most of the time something changed around you suddenly and you probably even
know the reason. in this case pain is a useful signal but it can get into the
way of resolving the underlying issue. e.g. if a bear is eating my leg then i
might just give up everything because it is too painful. maybe i would fight or
run more if the missing leg would not be bothering me. so in this case making
the pain go away might be very useful.
</p>

<p>
the chronic pain is different. and by chronic i mean the one that last for very
long time. i do not mean physiological pain only but mental too. inconvenience
might be a better term for the latter. we cannot simply wish the chronic pain
away. so what do we do? we medicate ourselves with painkillers. in the
inconvenience&apos;s case we start using various tools and gadgets to make things
more comfortable. this indeed makes the pain go away so it is a reasonable
solution.
</p>

<p>
however you could look at this differently. pain is something that you are
intrinsically motivated to alleviate. what if rather numbing the pain, you alter
your lifestyle in a way that the pain is manageable? with this approach you do
not feel at mercy of your doctors and drugs anymore. you feel that you are in
charge of life. you start researching your pain. you start experimenting with
things. basically you get a goal and start living. all your actions start to
have a meaning. the &quot;why am i doing this?&quot; feeling is not around. it is not an
easy life. every day you wake up, the pain greets you. it does not allow you to
slack off. you remain passionate about alleviating your pain.
</p>

<p>
and the nice about this is that you can always inflict pain on yourself.
depressed because you are invisible and there is no point in life? start walking
barefoot on the streets. you will immediately notice trash or dog poo on the
ground. you will start moaning how all this trash and dog poo is bad for us all.
you might start picking up the trash in your immediate vicinity in order to make
it habitable for yourself or at least arrange a daily cleaning service on your
street. you start fighting for clean streets. you now matter because you want to
achieve something. and that something is only about fixing your inconvenience:
making sure you can walk around barefoot without getting too dirty.
</p>

<p>
others will think you are crazy. they will try to talk some &quot;sense&quot; into you.
get shoes or else all sorts of bad thinks will happen to you. some people will
even get angry at you. do not let them to get to you or otherwise discourage
you. do not take naysayers seriously. ignore them. you cannot achieve something
without making some people angry. let them have their boring life. yours is now
full of excitement and possibilities. focus on that. after a while you will not
even notice the pain anymore. your body adapted to it naturally. it learned that
this pain might be okay after all and decided to not to bother you anymore. all
you need to survive is the initial period of the pain. do not underestimate your
body&apos;s and mind&apos;s adapting capability.
</p>

<p>
this does not mean that you should go all out and do all sorts of crazy stuff.
it works only up to a point anyways (yerkes-dodson law). and this takes a very
special personality. most people are not up to this. there are two lessons you
can take away: 1. if you ever feel uncomfortable, maybe keep yourself in that
state just a little longer just to see what happens, 2. if you see other people
doing crazy things despite the apparent pain, do not feel superior to them. all
the nice things we have today is thanks to crazy visionaries who went against
the establishment, made a lot of people angry and sometimes even suffered a lot
in exchange. try to understand their motivations instead. try to not obsess
about what and how they are doing things but rather what they are achieving.
after all, do not we all want clean streets?
</p>

<h2 id="thecook">thecook</h2>
<p>
i love my mom&apos;s fried chicken with fries! i want to cook my own. i know! i will
become a chef and prepare fried chicken with fries all day long!
</p>

<p>
alright, let me start immediately. the book says i need batter, oil, chicken,
potatoes. potatoes must be fried for a while so let me start cutting that! ouch
i cut my finger and there is blood everywhere. no matter, i apply a bandage a
keep cutting. i now put the potatoes into the fryer and off it goes. i prepare
the batter, cut the chicken fillets, coat them with batter, and start frying
them too. oh, the fries are ready. let me take them out of the fryer, and pour
them onto a plate. i salt them too. what is this smoke i smell? oh god, the
chicken is on fire! i did not set the gas stove correctly and it started burning
while i was preoccupied with the fries. quick let me put out the fire. i grab a
0.5 liter glass, fill it with water and pour it onto the frying pan.
</p>

<p>
my first attempt did not go well. at least i can do my next attempt in a new
kitchen. before doing that i decide to learn about this cooking more. i read
books, watch cooking shows and so on. one of the common advice i have seen is
&quot;separation of concerns&quot;. it says that i should not not try to do too many
things at the same time because i will be overloaded and i will not be able to
follow what is going on. that sounds reasonable.
</p>

<p>
okay, so now i have some experience: both practical and theoretical. let me try
this again. this time i do the chicken frying first. i prepare the batter, cut
the chicken fillets, coat them with batter, and start frying them. as i am
frying i watch the stove, adjust the settings. the chickens now seem the right
color so i take them out the fryer. my fried chicken is ready! now i can do the
fries. i start cleaning so that there is nothing else on my working table that
could distract me. i cut the potatoes. no finger cutting this time. i fry them
too. i wait, i take them out, and pour them onto a  plate. yay, i am done, this
will be awesome. i serve both my chicken and fries onto a plate and start
eating. ugh. the chicken is cold.
</p>

<p>
not too bad but i see there is more to learn in the world. so i study more. i
even attend a culinary course. they show me fancy tools and methods to follow. i
learn to be more efficient. there is not much benefit of cutting my own fries. i
can buy it frozen and it will be roughly the same. i can buy pre-battered fries.
and if i am very careful i can fry both of them at the same. i still need to
separate the concerns so i make sure that i fry in the opposite corners of the
kitchen so that i do not accidentally mix up the two. feels a bit weird but
sounds totally reasonable. after the frying is done, i serve the meal and
everything is fine! i can finally enjoy the fruits of my studies.
</p>

<p>
it is time for me to enter the big world. i start working at a big company among
many other chefs. we all prepare fried chicken and chips all day long together.
i learn lot from my colleagues. they even show me more advanced tools and
methods. i can now prepare this meal even more efficiently. i can see other
people also enjoying all the chicken and fries. life is wonderful.
</p>

<p>
time goes on. i feel a change in myself. something is not right. there is no
excitement anymore. is it because i do not like chicken and fries? no, that is
not it. i clearly like it still. then how come i do not want to do this all day
long? where did all the feeling of fulfillment from cooking go?
</p>

<p>
i start looking. i look at the cooking shows. they are all the same, do not
create any change in me and they seem boring. then one of the shows catches my
eyes. it has a special guest cook. a well renowned one. it piqued my interest
because this person seemed to be full of positive energy. it turns out people
find his meals masterpieces. yet people hate his guts for a reason still unclear
to me. i watch his cooking. then watch other people&apos;s reaction to his meal. i
feel excited again simply by watching him. but why? what is he doing
differently? i watch closely. after many hours analyzing the footage i distill
two observations. first he is like a barbarian. does not use most modern tools
he could use. he is not using the robopeeler, nor the robocutter for his
potatoes, he does all that by hand. this is silly but oh well. after the judges
start eating his meal, he continues to make adjustments and suggestions how to
consume the meal! he asks questions, suggests using a little bit of salt here, a
little bit of mustard there. he is quite eccentric. it went against everything i
learned: using tools and that my job ends when i serve the food. it is odd but i
want to be like him.
</p>

<p>
okay, but not use tools? this is silly but well, let me try it. this is painful.
i am cutting my potato and i just cut my finger again. i am frying my chicken
from my own batter without a timer and i overcooked it a bit again. and the
taste is quite meh. and my kitchen is a mess again. i have to clean it. but this
is odd. i feel calmness. i actually feel good now. i made the overcooked chicken
myself. i made it with my own hands. i did not need help from the robots. it was
me who put that chicken there. without me that overcooked chicken would have
been some other generic fried chicken again. i had a deep connection with that
chicken. this is fun!
</p>

<p>
the next day i do this again. this time i feel like i should go eccentric even
more and use crisps instead of breadcrumbs in the batter. this time i did not
cut my finger nor overcook my chicken. the chicken was really special, extra
crunchy. it was awesome! how come this is not the normal way to cook this? i
tell about this to some people and i get crazy looks. they never even bother to
try it. am i just imagining that this is that good? i continue experimenting
with various other tweaks. some work, some do not but i find a lot of joy in the
process.
</p>

<p>
so far all i did is the do stuff by hand. i want to try the second observation i
have noticed. the part where i actually serve my meal to others and see them
consume it. but where could i do this? i know! at my company!
</p>

<p>
i go to my coworkers and ask if they would mind if, when nobody is around, i
would use the kitchen to create a small dish for a few interested folks after
work hours. they say nice idea, go ahead. i am happy. i decide to create
something special that i cannot create at home because i lack a special
ingredient available only at work: cheese. so instead of fried chicken, i want
to create fried cheese. people still like the idea.
</p>

<p>
one of the company policies that whenever someone is in the kitchen, they must
have a coworker there for safety reasons. the coworker buddy is ought to stop
that someone from doing bad stuff and help out if accidents happen. there is a
guy i know who is really interested in all this cooking, i talk with him a lot
about cooking, i think he will be ideal as my buddy. i warn him i will be a bit
unconventional and then grab a potato and start peeling by hand. he immediately
stops me. i am doing this wrong. i should be using the robopeeler, have i gone
mad? i explain that this is really important. we start arguing about this. we
keep arguing until i actually manage to manually peel and cut the potatoes. i
start frying them. he is quite disappointed in me by this time. then i start
frying the chicken as well. he goes insane when he noticed that i did not start
the timer. &quot;frying without the timer is bad! it is very hard to know how long to
cook without the timer. and besides, it is company policy to always use the
timer!&quot;. then he grabs my frying pan, throws out my cheese out of it and gets
his own battered cheese, starts frying it but also starts the timer. &quot;see? this
is how it is done.&quot;.
</p>

<p>
on one hand he is correct. that is how this thing should be done. on the other
hand he managed to completely kill my mood and interest in this food. it should
not matter to me if the timer is going on for my chicken yet it does. simply the
timer being there annoys me. i do not get the &quot;i made this without robohelp&quot;
feeling anymore. i am getting back to the &quot;this is no fun, this is just plain
work&quot; state. what also annoys me that he also tells me how to do *my* stuff even
though he is completely uninterested in the end product, only in the cooking
process itself. i try to to explain that this is part of the magic i need in
order to make this meal but he does not budge. i get angry, do a super quick
cleanup and leave the kitchen because i do not see any point in continuing.
</p>

<p>
i keep thinking about the next step. i could leave the whole thing and just not
try make an interesting meal for a few folks. however i cannot let one person
get to me. i think i just need to change my buddy. there is this other guy. he
is pretty busy all the time just because he actually gets work done in the
company. he does not have time for petty arguments. but i will not get any
feedback or suggestions from him either. i ask him to my buddy and he comes. as
expected, he does not give much attention to me, he is doing his own job. on the
other hand i can finish my meal in the way i want. my guests come. i do not tell
them how i made this food other than it was a labour of love. i do not want them
to run away from me when they learn that i hand peeled and hand cut my potatoes
as in all the previous cases. i sit down next to the people who will consume it.
they like it. i feel happy about this. i recommend some salt here, some
mayonnaise there. i feel the fulfillment again.
</p>

<p>
people started liking what i create but at the same time people started hating
my guts. i am no longer pleasing all the people but in exchange i feel
fulfillment in my life again. i accept this tradeoff. all i need is to have the
courage to be disliked.
</p>

<h2 id="xgeec">xgeec</h2>
<p>
so the other day i was thinking about all these nudity and exhibitionism
fantasies again. i am not sure what to do with this. i have been nude with other
people but there is always something lacking which i cannot really put my finger
on. i have not actually tried this but even if i were to upload pictures about
myself naked, i think i would not feel any satisfaction either or it would be
temporary. i think it is the same with other explicit fantasies as well. even if
one could get some satisfaction, it is usually temporary and then they need to
do something again. i think maybe if one could gamify this whole thing, it would
keep people busy enough to trick them into satisfaction. so i have an idea. and
obviously as a tech person my idea is to use more tech. and it only applies to
this niche section of sexuality, the exhibitonism.
</p>

<p>
a sidenote first: i do not think the nudist lifestyle is an answer to this. for
a nudist being nude is normal. with exhibitionism some of the kick stems from
the fact that this is something forbidden or something that society disapproves
of. there is not much sexual energy in pure nudism. also, one could get easily
banned from most places for flaunting an erection.
</p>

<p>
so exhibitionism is about flaunting yourself in front of others potentially with
some innocent sexual connotations. and i think one gets more kick out of it in
real life than doing it online. however we shall not dismiss the power of
putting oneself online too. there are two problems: where would one find a safe
place for flaunting and what would be the point of flaunting?
</p>

<p>
my idea is to create a gamified social network site just for this! anyone can
register there. the point of the game is to connect with the most people you
can. there is a rule for establishing a connection with another member though:
the two people must upload a picture of them flashing their genitals to each
other. if they have the picture, they can become friends. in other words the
goal of the game is to meet locally with as many people as possible and take
genital pictures together! once they have a connection, they can chat with each
other. as a bonus, all uploaded photos and the member graph would totally public
for an extra kick. by the way xgeec would be a shorthand for &quot;exhibitionists&apos;
genital exchange&quot;.
</p>

<p>
totally crazy idea, right? who would ever play this game? probably not many
people. i would totally think about trying it though in order to help myself to
get rid of any shame that society imposes on us about our bodies and sexuality.
to help me learn to ignore what other people think about me (writing stuff like
this into this blog really helps with that though). to accept my body as it is
and not to be ashamed about it (i already managed to do this though). i just
assume there might be other people like this and as such i want a little corner
on the internet for us.
</p>

<p>
i have seen some dating sites, hookup sites, nudist connection sites but usually
they are very open ended and require a lot of effort to communicate what exactly
you want and then find the right people. xgeec would be laser focused on: 1.
arrange a quick meeting, 2. pull down trousers and underwear, 3. snap a pic, 4.
upload, 5. optionally put clothes back on. when the other person approves the
pic, the pic and the connection goes public. 2 and 3 can be done in a secluded
corner of a public place. there is not much place to second guess intentions or
for worrying about what will happen because there is a script and it is very
simple. one does the deed and it is over. it has a beginning and an end. one can
feel some after satisfaction establishing a connection. the connection appearing
publicly is the stimulating feedback one might yearn for.
</p>

<p>
it motivates reclusive people like myself to get out of the house because there
is very little string attached to acquiring a connection. it also helps me build
connections since in order to do this i need to meet with other, new people. as
i explained above, one can only talk to people they already have a connection
to. i would need to reach out to my existing connections in order to arrange
meetups with new people. even this can be motivating in itself: if i arrange a
meeting for someone else i feel like i am useful, that i am providing some value
to someone else. i would probably add a helpful metadata for this though: i
would allow tagging the pictures with &quot;weak tie&quot; vs &quot;strong tie&quot;. one would have
weak ties with people they do not know, they only met for the pic. strong ties
mean that the other party is a friend, they talk and stuff. when browsing
profiles, i could then see who could arrange a meeting with my target person: i
would be looking for a 3rd party that has a strong tie with both me and the
target rather than a weak tie.
</p>

<p>
a social network is worth nothing if there are no people on it. but i think it
would be super easy to seed this site compared to other social networks. this
site is not intended for building relationships or creating perfect profiles. it
is solely about uploading semi-naked group pictures. crypto geeks have their
&quot;key signing parties&quot;, exhibitionists could have their &quot;flashing parties&quot;.
suppose there are several folks interested in the site, all living in the same
city. i could find a small place for them where they could come to, snap a
couple group photos and then upload the pics afterwards. now the network is
seeded in that city and the members can start expanding the network via word of
mouth.
</p>

<p>
and this would be even super cheap to run. i would only allow 1 pic per profile
and 1 pic per connection. i would even aggressively downsize pics in order to
fit like 200kb since hosting high definition pictures is not the goal of the
site. furthermore i would delete all messages after 30 days so that i do not
keep stuff forever. maybe i would even delete pics after 2 years so people do
reconnect now and then. i would even delete profiles after 3 years of inactivity
so that the site is not a ghost town. i think the data for all this would be
peanuts, i could even run it on a free tier of a hosting provider. i should
totally create such a site. or even better: someone should beat me to it so i do
not have to deal with this all. this why i put all my ideas onto my blog but i
do not think anybody would ever bother with my crazy ideas.
</p>

<p>
one more observation: i think i really like this idea because there is a script
in it. i know what the game is about. i wonder if this could be generalized.
have a website that contains all sorts of weird sexual scripts that could be
acted out in a safe place. i am mostly talking about stuff that requires
multiple people since otherwise it would be about dating and hookups for which
there are a lot of sites. i talked about this in previous post but let me recap
some ideas:
</p>

<ul><li>
  nude workouts
</li><li>
  shaving clubs
</li><li>
  shared masturbations
</li><li>
  play something akin to the &quot;naked attraction&quot; tv show
</li><li>
  vanilla sex or orgies
</li><li>
  roleplaying (e.g. take a star trek porn and play it through)
</li><li>
  fetishes (servants, pain, anything)
</li>
</ul>

<p>
the website would contain various such activities in which the members can
express interest. if there are physically close members with common interests,
the site would match them. it would also offer a venue for the activity that the
members could pay together in case they do not have one. something like
meetup.com but for sex stuff.
</p>

<p>
maybe there is such a website but i did not find anything like that. i think
there would be a dime a dozen of such websites if sexuality would not be such
a big deal. things are getting better over time but i think there is still a lot
of room for improvement.
</p>
</body></html>
