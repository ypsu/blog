<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>notech.ie</title>
</head><body>
<h1>notech.ie</h1>
<ul>
<li><a href="#talking">/talking</a> game ideas.</li>
<li><a href="#shooter">/shooter</a> game i would like to see implemented.</li>
<li><a href="#task">/task</a> management must be done carefully.</li>
<li><a href="#liquid">/liquid</a> democracy is a neat idea.</li>
</ul>

<h2 id="talking">talking</h2>
<p>
suppose you have a friend or three. i like to imagine such hypothetical
scenarios. and further imagine that you throw or are invited to a small party
with them. what do you really do there? i don&apos;t really like music, dancing,
drinking and such. i&apos;m more of a sit in the quiet corner and listen to other
people sort of person. maybe play some game. but what game?
</p>

<p>
ideally it will be a game that isn&apos;t too complex and doesn&apos;t really require too
many props. i very quickly lose interest in games with many rules. and even if
you can follow them all, what&apos;s the point in playing such a game? i feel it&apos;s
just killing time. if i am already with people, i&apos;d want a game that focuses on
the people instead. it should make it possible for me to learn more about others
to see what people they really are. so basically i just want some structured
talking instead and the &quot;game&quot; could provide the structure.
</p>

<p>
one popular simple party game is cards against humanity. there is a list of
cards with questions on it, face down. each turn a player (called the czar)
turns a question card up and people have to come up with a witty answer to it.
each player has 10 cards with pre-written answer cards from which they can
choose from. or one could play this even without pre-written answers and rely on
people&apos;s inner creativity to come up with witty answers. the person who turned
up the question card has to pick the wittiest response. the owner of that
response wins the round. the answer cards should be shuffled before the czar
evaluates to avoid biased selection. this would be harder in the handwritten,
artisan answers but one could solve that by writing the responses on a
smartphone.
</p>

<p>
this is quite a fun game, potentially leading to fun times. the downside is that
you don&apos;t learn much from the other people, only their wittiness. so i was
looking for other similar games with more focus on the people themselves. and i
found some! and the rules are even simpler. i found two games and they go with
the names of &quot;disturbing friends&quot; and &quot;voting game&quot; and sort of came up with my
own rules based on the ideas behind these games.
</p>

<p>
the first game has question cards which contain a question and 2 to 4 answers. a
player, the round&apos;s czar, turns up a question card. the other players have to
guess how the czar will answer the question. the czar must try to answer the
question as honestly as they can. often there are no correct answers. in such
case the czar must pick the answer closest to their heart. each player has some
voting cards each with a number from 1 to 4. every player has to pick their
answer and put the corresponding voting card in front of them, face down. once
each player has voted, people reveal their vote one by one and finally the czar
reveals their answer. the czar wins (or loses depending on perspective) the
round if half or more of people didn&apos;t guess the answer correctly.
</p>

<p>
depending on the questions this can be quite fun with unexpected twists. you can
have a neutral question like &quot;best pet: cat/dog/fish&quot; and learn what animal the
czar likes. the czar also learns what other people&apos;s impressions of him are. you
can have a more politically motivated question like &quot;gun ownership: yes to
all/only license/banned completely&quot; to learn how people think politically. or
you can have a question like &quot;polyamory: it&apos;s a bad idea/ok but not for me/i am
polyamorous&quot; to learn other people&apos;s inclinations. the nice thing here is that
the game brings up the question, you don&apos;t really have to awkwardly bring it up
yourself in case you are curious about people&apos;s opinions on a topic. or you can
have a dirty nsfw question like &quot;my crotch has (select first that apply):
jewelry/scar tissue/ tattoo/other surprise&quot;. this is where the unexpected twists
can occur: maybe some people get intrigued by the czar&apos;s answer and then the
czar flashes their body to the party. that certainly could result in a lot of
fun from then on!
</p>

<p>
the ideal number of people for this game is about 4 so that the czar can see the
opinion of 3 people which is not too little, nor too much. but i think a couple
or a pair of people could also play this game. in such case the goal remains to
guess the other person&apos;s answer and see how well the two people know each other
and learn more about each other.
</p>

<p>
the other game is a bit simpler because it doesn&apos;t have a czar. you don&apos;t have
questions here but rather statements. each person gets assigned a distinct
number from 1 to n before the game starts. each round the group turns up a
statement card. people then have to vote which person is best described by the
statement. the round is won (or lost depending on perspective) by the person
acquiring the most votes. if there is a tie, people can break that verbally by
arguing who should be the winner.
</p>

<p>
a neutral question could be something like &quot;... cooks the best&quot;. people can then
see whose cooking they find the best. a more interesting one could be &quot;... can
hold their breath the longest&quot;. people might contest the result of the vote and
a fun breath holding contest might start. a nsfw statement might be &quot;... wants
to hang around naked&quot;. people then could then ask the winner &quot;do you really want
to be naked&quot; and maybe the party pivots into a fun naked party!
</p>

<p>
this game is probably best played with 5 people so that there are less chances
for ties. but i think this one could be played by a couple too. the couple just
decides between each other who wins each statement.
</p>

<p>
in order to play this game, one needs voting cards. one solution is to take
postit notes and write some numbers on them. the other solution is to cut up an
a4 paper into small slips and write some number on them. or even less effort
would be to find some coins or other small items. when you want to vote for 3,
you put 3 coins into your hand under the table and then show your hand when your
time comes. one doesn&apos;t need elaborate equipment or boards to play these games.
</p>

<p>
there could be some punishment or reward for the losers and winners each round.
ideas:
</p>

<ul><li>
  the losers have to make 5 pushups or squats each time,
</li><li>
  the winners can consume something of their preference,
</li><li>
  they need to remove or acquire a piece of clothing,
</li><li>
  they choose the background music for the next round,
</li><li>
  others can draw funny stuff on their faces or body,
</li><li>
  they need to be standing for the next round.
</li>
</ul>

<p>
it doesn&apos;t really matter much what it is but if there&apos;s some form of feedback
then that raises the stakes a bit and makes the game a bit more interesting. the
party members much agree on this beforehand so that everybody is comfortable
with the punishments.
</p>

<p>
one could print the question and statement cards but i don&apos;t think it&apos;s
necessary. as long as one has an app loaded with bunch of questions, one could
just use a smartphone to present the questions. ideally people should source
their own questions. nevertheless i decided to collect some sample questions and
statements and make a small tool for it that is convenient to use from a
smartphone. i even separated out the nsfw stuff so you can even play this in a
family friendly setting. but a warning: the nsfw stuff is quite strong, i
believe. only enable it with friends you absolutely trust no matter what happens
or people you don&apos;t know at all so that there are less stakes in the manner. if
in doubt, just look up the list of questions in the source of the webpage before
playing the game. the webpage has no dependencies so feel free to copy it
somewhere and edit the list of questions in it, e.g. remove the potentially
offending ones and add your topics of interest. you can find my tool here:
</p>

<ul><li>
  https://notech.ie/talking.html
</li>
</ul>

<p>
load that on a smartphone, select your list and put it into the middle of the
table and keep pressing next as the rounds progress. it has about 30 cards for
each type. if you ever try it then let me know how it went. i never tried this
so caveat emptor. maybe i&apos;ll have the chance to try this one day (with the nsfw
stuff included) and then i can improve it or list more tips here.
</p>

<h2 id="shooter">shooter</h2>
<p>
this is another of those fantasy posts where i think aloud what sort of game i
would try to make if i had infinite time, motivation and energy to do things. in
the past i sometimes did sit down and start working on a game but i always gave
up after the initial excitement evaporated. at this point, i&apos;m happy if i can
simply formulate what i would do. this way maybe my brain can give the obsessive
thoughts about the game a rest.
</p>

<p>
so usually when i think about making a game or software, i try to think only
about making the core work well and not care about making it fancy or good
looking. for me if the core is good, i don&apos;t need fancy graphics or user
interfaces. in fact, they would just get into the way. i&apos;d only need fancy
graphics if the core is just not good enough, and i&apos;d need some sort of eye
candy that sort of hides the fact that the underlying game is actually boring.
unfortunately most modern games are like that: they look very fancy but are
actually quite boring if you were to remove fancy graphics and replace it with
simple shapes (e.g. spheres). the question is: can you make a shooter that is
fun in itself even if it just consists of, say, spheres. e.g. each enemy and
each projectile, (hell, maybe even the walls) are just spheres?
</p>

<p>
one of the reasons i&apos;m actually not interested in making such a game, because
there is already one good free single player shooter game: brutal doom when
played on the original doom 2 maps. it runs on a relatively simple engine so it
can&apos;t do too fancy stuff. but what remains is basically superb. good feedback on
the enemies, good gun mechanics, good maps, no unskippable videos, no overlong
loading durations, no high computer requirements. it just gets everything pretty
much right. i couldn&apos;t find any other game coming near to the utility of this
doom 2 mod. actually, most modern games try to model things more and more
realistically which actually works against the fun of the game. if i wanted a
really realistic shooter, i&apos;d just go play paintball in real life. even though
we already have brutal doom, i wonder, can you go for a significantly simpler
game and still have it quite fun?
</p>

<p>
one of hard the problem of games is content. in case of shooters you need some
maps and some motivation and goal for shooting all the enemies. i really hate
the overly abstract games where you only play for scores. i&apos;m not very
competitive person, i want to enjoy the game alone, on its own, or if
multiplayer, then it should be some sort of cooperative game where you have to
play together to achieve a common goal rather than competing against each other.
competition is only fun while i&apos;m winning but if i&apos;m constantly on the losing
side, the game becomes quite boring for me. most of the time i don&apos;t want to
invest into the game enough to become competitive so i just stick to single
player games.
</p>

<p>
in this hypothetical game i would take the maps of doom 2. i like those maps
since structurally they are 2d maps yet they still contain rooms with various
heights so the fights have a vertical element. however good maps are not enough
alone. so i&apos;d also add some short story progression text between the level
transitions. i&apos;m not sure what sort of text but each transition text should have
the following properties:
</p>

<ul><li>
  it&apos;s short. about 5-10 lines of text (assuming 80 character lines).
</li><li>
  explains what the player achieved or learned in the previous area story-wise.
</li><li>
  shows a simple overview of the next area and their objectives (e.g. where the
  keys and corresponding doors are).
</li><li>
  explains why the player is entering the next area story-wise.
</li><li>
  mentions some hints about the map secrets so the player has something to look
  out for.
</li><li>
  progresses the main storyline in a suspense building way. the player should
  want to finish the next map just to see what happens.
</li>
</ul>

<p>
if it&apos;s possible, a few comics would also work but that sounds way too much
effort. text is enough if one is going for simplicty.
</p>

<p>
on the technical side, i&apos;d just hardcode the game resolution to 640x360. if the
graphics and gameplay are quite simple, it doesn&apos;t need a lot of detail. then a
smaller scale is more than enough. smaller scale means that the game is more
performant, it will work on very weak machines too. having a fixed resolution
makes a lot of things very simple: i wouldn&apos;t need to deal with supporting all
sorts of aspect ratio issues, making sure my fonts and heads up display are
legible, and many other things like that. i picked that resolution specifically
because scaling it 2x will get me 720p, scaling it 3x will get me 1080p. i like
such exact scaling because then the game can remain pixel exact. i don&apos;t like
blurry things.
</p>

<p>
there would be only one weapon in the game. i think it&apos;s important to pick one
weapon and focus on making the gameplay fun with that. i understand that game
can be more compelling if it has a lot of variety but that is not my goal here.
what i&apos;m trying to see if you can make a shooter based on a single gun
compelling enough. but what weapon should i pick? most shooters have 4 common
weapons:
</p>

<ul><li>
  sniper gun
</li><li>
  tracer gun
</li><li>
  shotgun
</li><li>
  projectile gun
</li>
</ul>

<p>
the first option is the sniper rifle with an optional zoom: this is a hitscan
weapon for very long distance battles. this can be quite rewarding but at the
same time quite frustrating if you have bad aim. it&apos;s also quite boring in the
sense that you are usually quite motionless, the movement is not that important.
so this gun doesn&apos;t satisfy the fun in the movement dimension. there&apos;s also the
problem of dealing with lag in multiplayer games. getting the correctness right
is quite a hard problem. one doesn&apos;t want to experience the fact that they
correctly clicked on a target, yet the server refused to acknowledge the hit. so
if one wants multiplayer, sniper rifles can get quite tricky to implement
fairly.
</p>

<p>
by tracer guns i mean guns that are hitscan weapons with high fire rate. the
player needs to trace the enemy continuously - keep aiming at the enemy while
continuously attacking to slowly destroy the enemy&apos;s shields and health.
examples are the machine guns in most old shooters, the lighting gun in quake 1,
the link gun in unreal tournament, or most rapid or continuous fire guns. these
are usually mid range weapons. my problem with this sort of guns is that they
are not as satisfying as the other type of guns. with a sniper rifle or shotgun,
you can eliminate the enemies with one shot if you are lucky. that&apos;s satisfying
because you get an instant feedback for an action. with tracer guns the gameplay
feels like a grind. gears of war contains lot of action like this and i find
that boring. that game feels like a chore. so i&apos;d totally avoid building the
main gameplay around this.
</p>

<p>
i love the overpowered shotguns in some of the games. brutal doom has it pretty
good. what i love about them the most is that in close range you can instant
kill the enemy, and gibs of the enemy fly away. it&apos;s a very satisfying thing.
and this also requires good amount of movement skill too. you have to run back
and forth against the enemy for the attacks because the shotgun is ineffective
outside its range. this is quite fun but the problem i think i have is that most
of the satisfaction comes from the effect of the gun rather than the skill of
the player. it&apos;s not super hard to play with it. and if you go with pure
graphics, a lot of the gun feedback goes away and it won&apos;t be as enjoyable, at
least not for long.
</p>

<p>
by projectile guns i mean guns that shoot flying projectiles that travel at
moderate, constant speed. think of the rocket launcher of quake and unreal
tournament, or the shock rifle&apos;s alternative attack in unreal tournament. i also
assume that this gun is not fast firing, so there&apos;s some delay between the
shots. i never really liked these guns for two reasons: they were slow so there
was a lot of dead time during action, and more importantly it&apos;s usually super
hard to hit moving targets with them. but i have to admit: hitting someone with
such projectile is very satisfying. but still, in total: not fun. at least that
was my opinion until i played shootmania which i think did something genius.
</p>

<p>
before explaining that, let&apos;s talk about the concept of ammo a little bit. ammo
adds a tactical dimension to a game. the amount of ammo you have changes your
tactic. full ammo? go guns blazing. low on ammo? play it very carefully, try to
eliminate enemies one by one with precision attacks. it also paces the game a
little bit. it forces you to explore the map for the resources. so it prevents
the game from being all action. in modern games you even have reloading, which
forces you to take mini-breaks from the action which helps you take a breath and
perhaps rethink your strategy. it&apos;s also a nice ritual you do after each battle.
it also helps to add a closure to a battle since you probably won&apos;t reload
during a battle unless you absolutely must. you do it when you feel your job is
done. i believe there might be also another psychological aspect of being more
vulnerable during a reload which also satisfies some internal craving of being
defenseless in a safe environment but i haven&apos;t thought about this aspect a lot
so let&apos;s not get into this.
</p>

<p>
the problem i have with ammo is that they take away from the purity of the game.
it makes the players inequal. the person with more ammo is at an advantage. so
at this point the game is not pure shooting skill, but also map control tactics.
both shootmania and mass effect solved this very nicely while still retaining
some of the above mentioned benefits: just have infinite, slowly recharging
ammo. in shootmania you have a single gun: a gun that shoots projectiles. but it
has a catch compared to the above games: there&apos;s no splash damage, you have to
hit the other player to frag them. that in itself would make it super hard but
to counteract this problem, you can shoot the gun as fast as you can. so you can
spray your enemy with projectiles. but that in itself would make it like a
tracer gun so to counteract that, you have only 3 shots in the gun. but they
quickly recharge, so even if you shoot away all your charges simultaneously, few
seconds later you can shoot again. however if you shoot as soon as your first
charge is ready, you&apos;ll need to wait again for your next shot. so what happens
often in close battles is that you have two players dancing around each other,
waiting for the right time to start attacking. too soon - they will have less
charges available - less chance of hitting the enemy. if they wait too long, the
enemy might start spray attacking sooner giving them a high chance for defeating
the player. and there&apos;s no unnatural need to run away from a battle due to lack
of ammo. the only thing the player needs to concentrate on is the other player
and the timing. it&apos;s as pure skill as possible.
</p>

<p>
so that&apos;s one aspect of gameplay. the other aspect is that you have a projectile
gun which means it&apos;s incredibly satisfying when you hit the other person. with a
typical hitscan weapon you just need to move the cursor over the other person&apos;s
avatar and shoot. it&apos;s a very mechanical skill that requires very good reflexes.
with projectiles you don&apos;t need to do that. all you need to do is to predict
where the enemy will be in a few seconds in the future. the nice thing about
this is, that you can compensate for bad reflexes simply by increasing your
distance to the enemy and making better predictions. and it&apos;s not like your
predictions must be absolutely perfect. the projectile balls are quite sizeable
so you have quite reasonable margin of error. and since you can spray 3 shots in
a row, you can cover a larger area. or even shoot tactically - use the first
projectile to make the enemy go down a certain path where you&apos;ll greet them with
your second projectile.
</p>

<p>
to summarize: i think a fast shooting projectile gun with limited but recharging
ammunition is the best gun to make a pure skill based bare bones shooter.
</p>

<p>
alright, we got the weapon down. next up is health. in general i think the
concept of health is silly. especially recharging health. if you have the
concept of health, then you start worrying about health. that takes away from
the pure shooting skill. i think the best thing to do is just to have instant
death. if you hit the enemy, the enemy dies. if the enemy hits you, you die.
shootmania actually gives you 2-3 lives so the first shot doesn&apos;t kill you
except for certain gamemodes. i think that&apos;s fine too up to a point. but if i
have to be as pure as possible and choose one gamemode, i&apos;d go with one hit one
kill. my motivation here is to simply not allow place for mistakes. if you win a
level then you should win it without any mistakes. that way you will feel the
best about yourself, that&apos;s how it should maximise the feeling of achievement.
</p>

<p>
keep in mind that i&apos;d play this game on doom 2 maps. they are relatively quite
small and if you don&apos;t hunt for resources, you can pretty much run through them
quite fast. so you wouldn&apos;t need checkpoints or savegame support. the game would
be only about the fact whether you can run through the map without a mistake or
not. the main challenge would be about you avoiding the enemy attacks until you
either manage to run past them or eliminate them based on your preferences. you
make a mistake, you quickly start from beginning and you keep trying until you
can do the level without a mistake. no messing with healths and lives and
whatnot. just pure movement and shooting.
</p>

<p>
and now come the enemies. i&apos;d represent the enemies as spheres. the projectiles
are also spheres so the collision detection becomes quite easy if you only have
the spheres to spheres case and spheres to a static geometry. and drawing them
is quite easy too: all you need to draw is a quad with a special shader that can
correctly project a spherical texture to that quad with a 3d effect. you don&apos;t
really need full human-like geometry to make the shooter fun. you usually need 3
pieces of information about an enemy:
</p>

<ul><li>
  position of the enemy,
</li><li>
  the direction of the enemy&apos;s movement,
</li><li>
  the intent of the enemy.
</li>
</ul>

<p>
the position is quite easy to solve: the enemies have a face. you know the enemy
is facing towards you if you see their face. you just need to map the texture
correctly.
</p>

<p>
you can implement the intent easily too: you just draw a different face for
different action. e.g. if the enemy is preparing to shoot you, you could have a
texture where one of their eyes is closed and they are squinting. of if they
want to dodge, you just draw a big open mouth suggesting they are taking in air
for the jump and have their eyes look into the direction of they planned dodge.
</p>

<p>
the direction of movement is a bit trickier since you can&apos;t represent that with
texture tricks. you need two things: you need to implement &quot;bobbing&quot; during the
movement. basically the sphere should move slightly up and down to indicate the
movement. this is important because if they are moving towards or away from you,
this would be your primary hint. secondly, you need to implement a &quot;footsteps&quot;
like effect. basically every half a second add a quickly fading smoke effect in
their position at the given time. the point is that you should be able to see
the trail of their recent movement. this and the bobbing should be more than
enough indication of the direction. although the technique is relatively simple,
it needs a lot of finesse to get it right for maximum utility.
</p>

<p>
as for enemies, i wouldn&apos;t go overboard either. i&apos;d implement only 3 enemies:
</p>

<ul><li>
  biter
</li><li>
  diver
</li><li>
  spitter
</li>
</ul>

<p>
all three enemies would be quite mobile. if you shoot towards them, they will
try to dodge the projectile. so you actually need to get close to them to battle
with them. the game would be about close to mid range combat. of course that
doesn&apos;t mean you can&apos;t land the occasional lucky shot but it should be rare (but
incredibly satisfying). and of course the enemies have only one health too, so
the challenge is all about hitting them while avoiding their attacks. as for
differentiating the enemies: i&apos;d just probably color their spheres differently
and that&apos;s it.
</p>

<p>
biters are enemies that try to run towards you, jump on you and then bite your
head off. they are quite easy to deal with as long as you don&apos;t let them get too
close. if you do, you have to very carefully dodge their jumps.
</p>

<p>
divers are flying enemies that fly near you and once close, they dive towards
you. very similar to biters the only difference is that they are not constrained
to the floor. some doom levels have flying enemies, and having some vertical
enemies adds some extra flavor to the game anyways.
</p>

<p>
spitters also run towards you until they get to a mid range, and then they shoot
projectiles at you. they should be the closest that come to playing against
other players. and your projectile avoiding techniques must be top notch to
avoid their attacks. they should be able to predict your movements via simple
linear interpolation and thus you can&apos;t simply run around to avoid attacks, you
would need to move in a completely inpredictable way (which i often struggle
with). they can&apos;t spray projectiles like you can do, but if there are multiple
ones, that means a lot of projectiles to avoid.
</p>

<p>
in general i wouldn&apos;t put too many enemies on the map since you only have one
health. too many enemies would just a grind anyways. maybe about 3-7 enemies per
room depending on the size of the current room. that should provide plenty of
spatial challenge in avoiding the attacks, and a tactical challenge in shooting
them all quickly enough.
</p>

<p>
so that pretty much sums it up. i know one could extend this with gazillions of
stuff. but if i were to make a basic game, i would totally start with only that.
i think the above should be more than possible to finish someone in a few months
from total scratch in c and yet still end up with a quite nice game that doesn&apos;t
need a lot of polish.
</p>

<h2 id="task">task</h2>
<p>
like most folks i also have a barrage of ideas, requests, commitments, chores
and so on that i just need to do. since i don&apos;t have perfect memory, i need a
system for managing them. every person manages this differently: some just rely
on their memory, some use sticky notes, some use elaborate software, some use
bullet journaling, and so on. there&apos;s no system that works for everyone. i&apos;ll
now share what works for me.
</p>

<p>
first it&apos;s important to define what your end goal is. a typical goal is &quot;to be
productive&quot;. that doesn&apos;t work for me. i don&apos;t care much about productivity. my
primary goal is to become &quot;free&quot; - free of the tasks. ideally my todo list is
completely empty. if it&apos;s empty then it means i&apos;m pretty much free to do
whatever i feel like doing. that is usually daydreaming which usually leads to
bunch of new ideas which then fills todo list again. so even though the todo
list doesn&apos;t stay empty for long, it&apos;s super important to be able to
occasionally achieve 0 outstanding todo items. if i can&apos;t achieve that, then
that is a singal to me that i&apos;m doing something wrong and i need to sit down and
holistically reevaluate my priorities. keeping the todo list near empty means
you can be more flexible, can easily change directions, try new things, be super
responsive to people without feeling much dread about all the tasks you need to
do. but near 0 outstanding tasks is super hard to achieve regularly. however one
can create the illusion of low task load simply by hiding majority of the tasks!
not all tasks are the same. i&apos;m not really fond of hierarchies or labeling
things but i do have 4 categories for my tasks:
</p>

<ul><li>
  conditional tasks
</li><li>
  stashed tasks
</li><li>
  queued tasks
</li><li>
  archived tasks
</li>
</ul>

<p>
conditional tasks are the best! those are tasks that you want to do but you
can&apos;t. suppose you need to talk to a person about a topic but that person is
traveling. you can&apos;t talk to him until they come back. it means this &quot;talk to
person x&quot; task has a date condition. you just need to hide the task until a
specific date. or you want to remember that you need to do a regular, yearly
maintenance on your car. you can just add a task that is triggered on a certain
day of the year. you&apos;ll see the task in your todo list from that day on until
you clear the task. once you complete that task, you readd the condition to the
task but with the year bumped.
</p>

<p>
one might use a calendar for this. however that is wrong! the problem with the
calendar is that you&apos;ll see all the upcoming tasks if you look at a weekly or
monthly view of the calendar. if you see the task, you&apos;ll remember that you&apos;ll
need to do it at some point and you might start stressing about the upcoming
burden. and it&apos;s all pointless because you might not be able to act on the task
since its trigger date has not passed yet. it&apos;s really important to keep the
conditional task hidden until it&apos;s triggered. surprisingly many tasks can be
hidden simply behind a date.
</p>

<p>
on my personal computer i have a &quot;.rems&quot; file standing for &quot;reminders&quot;. each
line in it has the format of &quot;yyyy-mm-dd some arbitrary text&quot;. you might notice
that the filename starts with a dot which means it&apos;s a hidden file. i don&apos;t want
to be aware of this file. most of the entries from it shouldn&apos;t be triggering,
so i shouldn&apos;t care or know about them at all anyways. i also have a &quot;todo&quot;
script which prints a portion of this reminders file (among other things like
checking my email). it prints the lines whose date is in the past. i run my todo
script occasionally, yet most of the tasks from the reminders file stay hidden
until they are actionable by me. i can completely forget about those tasks and
still remain calm that i&apos;ll see them in time (unlike the calendar where i&apos;d see
the tasks all the time).
</p>

<p>
furthermore in certain environments one can be even smarter about this. at work
we have a relatively simple issue tracking system. each issue can have an
assignee field. if you have an issue assigned to you, you are expected to do
something about it. fortunately we have a nice robot to which you can reassign
these issues with a condition. you can tell it &quot;please assign this back to me
once that other issue is fixed&quot; or &quot;please mark this as fixed once that commit
is pushed&quot; or &quot;please assign this to person foo when person bar is back from
vacation&quot; and gazillion other actions and conditions. if you use this robot
well, you can hide a lot of your unactionable tasks. suppose you have an issue
assigned about a bug to you and you already created a commit to fix it and sent
it to review. at this point you can&apos;t do much about the issue, you are waiting
for the other person. so you tell the robot to keep the issue hidden until the
bugfix is pushed. after the review you push the commit. at that point the issue
reappears and you can, say, send out an announcement that you fixed the bug and
close the issue. having the issue hidden means cleaner dashboards, smaller todo
lists, and simply less mental tax. i love this tool at work and use it to keep
my work task count quite small compared to the rest of my colleagues.
</p>

<p>
you can also use conditionality to spread out tasks. one example is when you
have multiple issues that you have to solve in order. you can use the above
robot just to chain them up and in any given moment you&apos;ll only see the first
issue that you need to work on. once you close that, the next one appears
immediately. it makes work much streamlined - you always know what to work on.
this trick also works for unrelated tasks. there&apos;s only so many things you can
do at any given moment. you can decide that you create some sort of order over
the tasks based on importance and chain them based on that. for instance there&apos;s
a person i like to chat with and i always come across topics or ideas that i&apos;d
like to talk about or just get their general opinion on. but if they are
traveling i can&apos;t talk to them. at the same time i don&apos;t want to forget the
topics. i also can&apos;t talk about all the topics with them at the same time when
they come back. so in such cases i just chain the topics. i mark the first topic
to appear in my todo list once they are back and keep it there until i managed
have a talk about it. after the talk i go back to my machine and cross it out
and the next one appears - which i&apos;ll remember the next time i meet them. it&apos;s a
pretty simple way to keep many things in your todo list without being overloaded
by them.
</p>

<p>
there&apos;s one additional benefit of the conditional tasks. the conditions
themselves also serve as a communicational tool. it communicates what a task is
waiting on. so if somebody is getting impatient with a task&apos;s state, they don&apos;t
need to bug you, but they can look and challenge the condition directly. e.g. if
an issue is waiting on a commit and the commit is waiting for a reviewer, then
they can ask the reviewer directly when are they going to finish the review.
</p>

<p>
my next big category is the &quot;stashed tasks&quot; one. some people call these the
iceboxed issues. a lot of times a random idea comes to my mind that i&apos;d really
like to do, investigate, experiment with further. however often such tasks are
not super urgent or important. i just want to be sure i don&apos;t forget about them
until i completed said task. sometimes i want to keep a thread of thought open
somewhere until i make my mind up about something. basically these are tasks
that i want to track but not to be reminded about. since i don&apos;t look at this
list proactively, this list tends to contain a huge number of tasks. but that&apos;s
fine. i encounter many ideas day to day. if i don&apos;t write them down into a safe
place, i tend to obsess about the idea a bit because my brain doesn&apos;t want to
let go of it until it senses some sort of closure. writing it down to my stashed
tasks lists gives it that closure.
</p>

<p>
ideally this list shouldn&apos;t be growing unbounded. it would be only consulted
when the primary todo list becomes empty just to find new things to do or when i
left some notes about some particular topic which i now want to look up. if i&apos;m
looking at it because i don&apos;t have better things to do then i can either do some
of the tasks i always wanted, or just clean up old, irrelevant entries from the
stashed tasklist. one always feels pretty good after such a cleanup.
</p>

<p>
i implement this by having a simple &quot;.ideas&quot; free-form text file on my computer.
i just randomly add stuff to it whenever i think of something. it&apos;s also a
hidden file since i want to keep it out of sight. i do have a little structure
to this file since it is quite long. each task has a title and i prepend a &quot;#&quot;
sign for those titles. the subsequent lines are the notes related to the task.
the nice thing is that this way i can have a quick overview of all my stashed
tasks simply by running &quot;grep ^# .ideas&quot;. i don&apos;t use more structure than this.
</p>

<p>
at my work there are several ways to achieve stashed tasks. the issue tracking
system actually supports two levels of assignments: &quot;assigned&quot; and &quot;accepted&quot;.
in theory you can assign any issue to anyone and the other person should mark
the bug as accepted once they plan to work on it. so technically you could use
&quot;assigned&quot; for the stashed work and &quot;accepted&quot; for the work you actually want to
work on immediately. however this distinction is not well understood, recognized
or used so even though i could use it personally, i don&apos;t do it. in fact, i try
to avoid stashed tasks at work completely. if i have such work related
unimportant idea, i write it to my personal .ideas file. at work i&apos;d just simply
close or unassign such an issue. this clearly and unambiguously signals to other
people that i do not plan to work on an issue. you can also add issues to a
&quot;hotlist&quot;. basically it&apos;s like twitter hashtagging but for issues. you can add
arbitrary issues into arbitrary hotlists. e.g. you could create a &quot;my stashed
issues&quot; or &quot;icebox&quot; hotlist, and just add issues of interest into that. you can
keep the issues unassigned so people who want to see the status of an issue can
clearly see that nobody is working on it. this approach also works on a team
level. if a team wants to track some issues but not work on them, they can hoard
them in such an icebox hotlist. generally speaking such hoarding is not very
healthy but it can make people feel calmer due to having a place to gather
thoughts about certain issues.
</p>

<p>
when one works with documents or source code, they can also leave todo comments
in the middle of the document. it&apos;s a very low overhead way of tracking tasks.
at my work they have the form &quot;todo(username): some text&quot; or &quot;todo(issue/12345):
some text&quot;. i&apos;d treat &quot;todo(username)&quot; as a queued task (will explain shortly)
however &quot;todo(issue/12345)&quot; is less clear. if issue/12345 is a stashed task then
that todo comment task can be treated pretty much as stashed as well. you can
think of these as mini-issues that block the main issue. at my work we even have
a cronjob that periodically crawles the whole source tree looking for such
comments and marks such occurrences in the linked issue. for each issue people
can see all the outstanding blocking issues and todo comments as well. they
shouldn&apos;t close the issue until they clean those up. in fact they receive a
warning notification if they close an issue nevertheless. but the point is that
you can keep tasks right in your primary work documents as long as you have the
tooling to manage them.
</p>

<p>
next up are the queued tasks or active tasks. these are the tasks that you think
you&apos;ll be able to work on in the next few days. you really should keep this very
short. in a perfect environment without disruptions you should be able to finish
all of them within a week. if you can&apos;t because you have so much or so big items
on this list, then the list is pretty much useless. it&apos;s useless because then
there are tasks on it that will be never addressed, basically tasks that should
be stashed. however just because they are in your active tasks you&apos;ll see them
every day. you very quickly start to ignore those items. if you ignore one item,
you&apos;ll very quickly start to ignore other items. this then snowballs: you pretty
much don&apos;t even use this list to guide what you should be working on next. it
just drags you down mentally, reminding you that you&apos;ll never be able to reach
the nirvana of 0 tasks. this is why i prefer the term &quot;queued&quot; tasks. it means
you can&apos;t allow things to linger in this list. if possible, you should go
through the tasks in fifo manner - first in, first out, no matter what the task
is. even though it might not sound a super productive strategy but it builds a
good habit of not hoarding tasks. i often have some very small idea i want to
try. before i forced myself to use the fifo rule, i pretty much procrastinated
on such ideas and eventually even dropped them because i got bored by hoarding
them in my todo list. with the fifo rule, i&apos;m forced to be more exploratory and
i actually learn ton of new stuff this way. simply because i force myself to
work on or explore the random unrelated ideas i queue up in my active tasklist.
</p>

<p>
it&apos;s super important to keep this list realistic. only put stuff into that
you&apos;ll actually get to in the order of days. there&apos;s on exception: if your task
is big, then it&apos;s okay to keep an entry about it in there as long as you chip
away at the task every day. you can also put untriaged items into this list. for
example you can treat reading your unread email as your queued tasks. some
emails might prompt for additional investigation, you might keep this email in
your queued tasks until you figure out how to respond to it. the task itself is
the fact that you have to figure out the response.
</p>

<p>
you can even try some psychological tricks to reduce the number of tasks. a lot
of my personally generated tasks are just ideas that i really want to explore
and experiment with. you could save some time yourself if rather than just
jumping right into implementing the demo, you talk about the idea with someone
first. this means the task now is not implementing stuff which can take long
time and requires a lot of motivation to start, but rather just having a chat
about it with your buddy. basically transform the task to scheduling a meeting
with your buddy. the original task becomes conditional - the condition is a date
that is after your meeting. this is also a great way to get out of your comfort
zone and make yourself talk to other people. all being motivated from the fact
that you want to keep your queued tasklist small. and not only that, you might
even learn new things. your buddy might point to an already existing thing, give
you tips on how to simplify things and so on. there&apos;s not much to lose from this
trick.
</p>

<p>
management of these tasks should be relatively low overhead. different kinds of
tasks need different tools for optimal maintenance. my first tool is an
unstructured &quot;todo&quot; file on my computer. i just queue stuff to the end, and pop
stuff from the top. popping the top is not a strict rule, but just an ambition.
most of my own ideas land in this file. often i write an idea down there, and
once i&apos;m done with the initial brainstorming, i just move it to the stashed
tasks. however i might not always have an access to my machine. in those case
i&apos;ll open a draft email in my gmail. gmail adds a quite visible marker if you
have a draft so i&apos;m always aware of my drafts. however i strive to move my
drafts to my todo file from above once i get back to my personal computer. i do
this just to reduce the amount of places i have my tasks.
</p>

<p>
note that this &quot;todo&quot; file doesn&apos;t start with a dot - it&apos;s not hidden. making
this file present in my home directory reminds me that i have stuff to do. if it
were empty, i could just delete it. actually all non-hidden files and
directories in my home directory mean some form of outstanding item for me. if i
start working on a demo or experiment, i just create a directory for it in my
home directory and keep it there until i&apos;m finished with it. then i just either
delete it or move it to my &quot;.d&quot; hidden directory which contains all sorts of
random stuff. stuff that i need to keep around (e.g. a checkout of my dotfiles
git repo) or various random stashed things. &quot;d&quot; stands for &quot;drive&quot; or &quot;disk&quot;
suggesting i archive most large things under that directory. if i want to keep
something around for later work, i make a note of it in my stashed tasklist, and
move it to my &quot;.d&quot; dir. if i want to pick it up again, i can just either move it
back or simply symlink the directory from my home.
</p>

<p>
the next big source of active tasks are the email messages. email management is
a huge topic on its own, i probably can&apos;t do much justice to it. but let me try
to give it a short summary. there are 4 kinds of emails:
</p>

<ul><li>
  an actual conversation you have with someone,
</li><li>
  a notification of something personally relevant to you,
</li><li>
  a feed item, news, random chatter,
</li><li>
  items of interests that you won&apos;t read but want them to be available when you
  look or search for them.
</li>
</ul>

<p>
the first two categories are fine with me, i&apos;m happy to receive them since they
usually mean that i have to act on them. i don&apos;t have the 4th item at all. i
unsubscribe for all unnecessary updates and alerts. if i don&apos;t read it, i won&apos;t
know i can search for it anyways. at work usually such mails go to google groups
archives too so i can just use google groups search to find such emails. i&apos;m
quite strict about the third category. i subscribe only to a very few and
relevant feeds. if the feed only has an occasional post then it&apos;s not bothering
me. if it&apos;s high volume then i try to make it less high volume by trying to
eliminate unnecessary spam from it right at the source (e.g. i ask the robots to
stop spamming). if that doesn&apos;t work, i just change google groups to send
updates in bulk (so my inbox can remain clean) or just unsubscribe entirely and
remind myself to check on the group occasionally. i either just rely on my
memory to check on the feed - if i forget then it&apos;s probably not that
interesting anyways, so it&apos;s a good riddance and i can enjoy the additional free
time i got by not reading the feed. or i might add a date conditioned task to
check back on the group - usually for work related stuff i ought to know about.
but i try to keep these to the minimum. but it&apos;s all a moot discussion since
these don&apos;t generate tasks for me unless it&apos;s a list that i&apos;m supposed to give
support on.
</p>

<p>
anyways, let&apos;s get back to the main topic. whenever i see something in my inbox
that needs some further action or thought from me, i just simply star it.
starred emails are also part of my queued tasks. it might be the case that such
an email is either just good but long thread that i don&apos;t have the time to read
now, or it&apos;s blocked on something. in those case my action for that starred
email is to make a note of it in either my stashed or in my conditional
tasklists and then simply unstar it. that&apos;s pretty much my workflow: i read all
my email, i star the things i need to something about, and then when i have
time, i address the starred items. again, i actually follow up on those emails
quite quickly, i don&apos;t hoard them.
</p>

<p>
i also consider issues assigned to me as my active tasks. i either actively work
on them, or just reassign them either to someone more knowledgeable or to the
robot in case it&apos;s blocked on something. one annoyance with the issue tracking
system that most updates generate an email to every person cc&apos;d on the issue.
however fortunately my work&apos;s issue tracking system allows editing some of the
comment updates: you can edit your own comments and the issue&apos;s first comment.
these edits don&apos;t generate an email notification. so you can pretty much keep
updating an issue&apos;s first commit to match the &quot;explain the issue; explain the
status; make note of outstanding tasks&quot; format there. and then you make it a
personal habit to check and update the first comment before closing an issue.
</p>

<p>
the next tool i use is our internal code review tool. each commit has an author
and a set of reviewers. usually the author and the reviewers exchange comments
and changes until everybody is happy with the commit which is then pushed. the
tool itself has a very handy &quot;attention tag&quot; feature to manage whose turn it is
to respond. it&apos;s a boolean flag on the author and each reviewer. when the author
sends out the review request, the attention is on the reviewers. when the
reviewers respond, the attention moves to the author. people can flip the
attention on the individuals manually but by default the tool is quite smart
with managing it automatically. whenever i have the attention for a commit, a
small browser extension starts glowing. by default it is gray so when it
switches to a bright color, i notice that quite quickly but doesn&apos;t interrupt me
in any way in case i&apos;m in the flow. if a commit has my attention, i treat it as
my active task and my goal is to review the commit or respond to the comments
depending whether i&apos;m the author or a reviewer. even when i&apos;m the author of a
commit, once i send it out for review, it pretty much disappears from my active
tasks and i can immediately focus on other things. note that i can send the
review request to a robot along with a condition here too. the robot will keep
the attention tag on itself until the condition is true. then it assigns back
the attention and leaves the review thread. this gamified workflow of attention
tag ping-ponging makes it very gratifying to stay on top of the review workflow.
</p>

<p>
so those are my main channels for the active tasks. again, it&apos;s super important
to ensure you treat them in timely manner. in fact, it&apos;s best if you commit that
every day you&apos;ll start your day by addressing or making progress on your oldest
item from your queued tasks. the benefit of doing this is that you always have a
clear task to start the day with. once you do that, you&apos;ll feel that you
achieved something, and you&apos;ll be even more motivated to do more things rather
than just procrastinating all day on the internet. however in order for this to
work, your tasks in this list must be crystal clear rather than vague. if you
have a task which is unclear on how to solve, then your task is to figure out
how to solve it. most of the time it means writing to a support list or just
scheduling a meeting with your mentor or buddy to give you guidance. reaching
out to a person is always relatively easy, so you should always be able to do at
least that, no matter what the task is.
</p>

<p>
next up is the archival of tasks. i neglect this most of the time. however now
and then i want to be able to remember that i did something and how i did
something. i want to be able to refer back to my old notes. i don&apos;t worry about
this at work because the issue tracking system will keep all the notes and
comments around viewable by anyone. the more interesting question is what to do
with the completed personal tasks. the simplest thing to do this is just to have
a private journal. every time something comes up, you just append a note to the
end. in fact, i hear that doing daily journaling is quite healthy for one&apos;s
wellbeing. sometimes if i&apos;m in the mood, i do write some notes about every day.
but i quickly run out of steam. but if some important happens, i usually always
add it to my journal. i keep a &quot;.notes&quot; file in my machine and just write to it.
every new year i rotate this notes file. i just put the contents of the journal
into an email and send it to my email address. this way i don&apos;t have an ever
growing file on my machine and i can easily refer back to my notes via the email
interface&apos;s search facilities.
</p>

<p>
there are other ways to archive tasks and ideas. one way is to write about them
to someone. if i learn about a nice idea or nice article, i often just send it
to a buddy along with some personal comments. one, this sometimes starts a nice
discussion, two, i can easily refer back on the letter later. the benefit of
doing this over the journal is that it&apos;s much easier to remember about this
because you also talked about it with the other person. so even if you can&apos;t
remember how to find your notes or article again, you might remember who you
talked to about it, and just ask them if they remember anything. basically you
are outsourcing your memory to other people. it&apos;s also a nice way to keep some
social interactions alive.
</p>

<p>
another alternative is to write a public blog post about the idea. i think this
is one the best things you can do if you have the guts to publish stuff online.
this forces you think about things very carefully, forces you clear up your
thoughts so that they can be put into words. and if you are not shy, you can
even share the post with others. once it&apos;s published, you can pretty much forget
about the idea, unless others come back to you and become interested in your
specific idea. it can also act as a nice survey to see how good an idea is. if
people don&apos;t seem to show interest after you show it to them, maybe it&apos;s not
worth pursuing it. if they do, that interest can actually act as a motivation to
start working on the demo. having said that, i don&apos;t popularize my blog. i write
a lot of crap here that might be better if people wouldn&apos;t know about me. maybe
when i&apos;m older, this will become easier and i won&apos;t care about all this. it
would be awesome if people would ask me about my posts after i wrote them
though. but i don&apos;t want to keep notifying them about my posts - i want them to
learn about the posts because they are interested in the posts and explicitly
started following me. i want genuine interest rather than pleasantries. but for
that i&apos;d need to learn to write interesting posts, but let&apos;s postpone acquiring
that skill for a later day.
</p>

<p>
having said all that, there&apos;s no reason you can archive a task only in one
place. you could write a post, share it with a friend, and then finally mention
it in your journal. in fact, that would be probably the ideal habit if you have
the grit for it.
</p>

<p>
if you see some very old tasks in the stashed lists, then they are very good
candidates for archival. in fact often it&apos;s best just simply decide not to do
some tasks. give some thoughts about it, write down how you would go about them,
publish them on the blog, and then just forget about them. at least this way you
give yourself the closure that you gave the idea some attention but still didn&apos;t
waste too much time on it. and since it&apos;s on your blog, you know you can always
refer back to it from anywhere if you feel nostalgic about an idea. or just
point to your blog entry whenever you see somebody else thinking of a similar
idea. ask them to take a look at yours to see if they can use that as an
inspiration.
</p>

<p>
anyways, that&apos;s pretty much how i manage my tasks currently. although i wrote
quite a lot and i need custom tooling, i think my system is relatively simple -
mostly consisting of 3-4 unstructured text files for most cases. i wrote a lot
because the system is quite powerful and needs lot of explanation to explain
said powers. i&apos;ve seen more complicated systems used by people which eventually
turned out to not being very effective for them. especially after they ran out
of steam maintaining the required process or structure. task management must be
low overhead. and i&apos;d reiterate again, task management won&apos;t get you out of
unproductivity and procrastination. i&apos;m not using this for that purpose. i&apos;m
using this system simply for tracking and making an order of my outstanding
tasks and ideas in a relatively low-overhead but featureful system. although i
haven&apos;t tried, a similar method can scale up for teams as well, not just for
individuals, it just needs careful thought. i&apos;ll spare the speculation about
this aspect for now though. i&apos;m still relatively new to managing my tasks this
way (couple months) but let&apos;s see if it crumbles down or not.
</p>

<h2 id="liquid">liquid</h2>
<p>
i always had problems with politics and voting. my problem with today&apos;s form is
that the system is way too simplistic and rigid. in the end the choice usually
boils down to choosing between two parties, the one you hate less. then wait and
hope things do not go way too bad. this is a false choice to me. i feel
completely disconnected from the process and therefore i feel like abstaining
until i see a better alternative.
</p>

<p>
i came across the liquid democracy idea which is pretty neat. i will not go too
deep into the details or merits of the idea but the main idea is that people can
vote on directly on the issues or appoint delegates that can vote on their
behalf in issues related to specific topics. people can change these delegations
at any moment. this makes campaign circus every 4 years somewhat obsolete which
is also a nice benefit.
</p>

<p>
it is also important to note that it is actually quite easy to migrate to a
democracy like this if people wish so. one can create party that provides the
above system and then commits to vote in the office according to the people&apos;s
wishes. if a person wants to vote for party x, they could still vote for this
proxy party and in the system they would set their preferences to follow party
x&apos;s votes. i understand politics is more than just voting but for the sake of
brevity i only want to focus on this part for now.
</p>

<p>
there is only one problem with this idea: it is not obvious how to maintain
anonymity in this system. i did a quick internet search but did not find much
discussion around the topic. i did find a lot of blockchain mumbo jumbo as if it
would solve anything in this aspect of the problem. or the other things i found
was questioning this feature of democracy which is also quite absurd. i am sure
there are lot of good solutions to this but before searching deeper, i like to
give it a thought of my own: how would i reinvent things with zero practical
knowledge. writing down just helps me make the ideas more concrete. i will get
everything wrong but at i might learn something out of this when i am reading
about serious solutions.
</p>

<p>
my system would have couple important concepts:
</p>

<ul><li>
  public profile: this is a person whose identity is publicly known and their
  votes are publicly visible for accountability. these people would be the
  &quot;politicians&quot; who would be publicly standing up for various things. anybody
  could register as a public person. voters can delegate votes only to public
  people.
</li><li>
  private profile: this is a user in the system without an identity attached.
  they can vote directly or delegate votes to public profiles. this is what most
  people would register as.
</li><li>
  issues: this is what people can vote on. you have a question and a list of
  outcomes that people can vote on. there would always be an option for
  abstaining, and also for marking the question as invalid or false choice. i am
  not sure about the voting algorithm though: i am vacillating between approval
  voting and instant runoff voting with optional preferences. i like the former
  for its simplicity. on the other hand the latter has even better properties at
  the cost of much harder decisionmaking at the voting time.
</li><li>
  tree of topics: each issue must belong to a specific topic. and each topic
  must belong to a parent topic (there would be a root topic). this is only
  needed for categorizing the questions for the convenience of delegations.
  think of topics as directories, issues as files in those directories if that
  makes it any simpler.
</li>
</ul>

<p>
had i a website for this, i would not allow much discussion to happen on the
site other than casting the votes. this way there is no need for moderation
which can avoid a lot of problems and makes the site lightweight. as to where
the votable issues coming from: that is a bit outside scope of this brainfart
but the general gist is that it would go through formal channels and the only
people that can suggest votable issues are the people who then agree to be held
accountable for the outcomes.
</p>

<p>
one familiar with the concepts of liquid democracy can probably already imagine
how one could create a system using the above concepts: after people log in,
they can see issues, cast their votes directly, or set up delegations to public
profiles for specific topics (e.g. healthcare, education, or just
education/highschoolers). they also see their historical votes, and what
delegation chain led to that vote if any.
</p>

<p>
however two issues remain: how to ensure one person can have only one account
and how can someone verify that their vote counted.
</p>

<p>
i assume that the country already has a way to uniquely identify its citizens
with some sort of official id card. i imagine this algorithm after i decided
that i want to participate in the voting anonymously:
</p>

<ul><li>
  i go to an official registration office where i show my id card and i receive
  a ticket in exchange.
</li><li>
  with the ticket i can register into the online system from home and
  participate in the votes for a limited time.
</li>
</ul>

<p>
my main goal here is to ensure the fact that there is no computer system that
somehow associates my identity to my profile in the voting site. in order to
achieve this my idea is to split the registration into two steps done at a
different time by different organizations.
</p>

<p>
for simplicity let&apos;s assume the registration part happens in january (no voting
during that time) and voting happens during the rest of the year, from february
until december.
</p>

<p>
in january the first organization checks my identity and then it records this
fact into their database. this registration fails if i am already in the
database. the only thing the database records is the unique identifier on my id
card (e.g. social security number). then as a proof they (or some other trusted
organization) issue me a ticket which is a pair of public and private keys which
i can use as a proof that i correctly proved my identity. the ticket&apos;s public
key goes into a separate database so that the ticket is not linked to my id
number. the organization throws ticket&apos;s private key away, only the voter keeps
it.
</p>

<p>
on the 1st of february this organization would release the list of people who
registered for voting and the list of public keys of the tickets the system
generated. the two lists are not connected but they should have the same number
of elements. this way people could check who registered for voting and also
ensure that there are no invalid tickets maliciously generated (or if there are,
it&apos;s obvious). though the only way to audit the lack of invalid registrations
would be to confirm with every registered voter that they indeed registered.
independent auditors can probably use some statistical methods to estimate the
number of invalid registrations.
</p>

<p>
the second organization is the one that runs the voting site. in order to
register here you need a valid ticket from the first organization. you need the
private key for the registration and one ticket gives one registration only.
this way no person can register as another person unless they stole their
private key but in that case the former person cannot register. again, this
error is detectable even if not correctible. this system also does not collect
anything other than a (perhaps randomly generated) username and password. no
email address even to avoid the possibility of linking data after a leak (again:
users should use separate sites to keep informed about what is going on; i am
imagining an infrastructure service, not a social networking site). even the
ticket&apos;s public key is not linked to a specific user other than marked as used
in a separate table.
</p>

<p>
the registration is valid only for a year. people will lose passwords or have
their accounts hacked. since the system itself does not link accounts to the
real people, those accounts will be lost until their expiration. this would be
the cost of people not being careful with their password (a sort of perverse
democratic darwin award). however the damage is only temporary because next year
people can re-register.
</p>

<p>
the other problem is accountability of the votes. i think the solution for that
is just public dumps of the actual votes. after each vote the system releases a
big file that contains a row with 2 elements: random unique number identifying
the voter and the actual votes (the delegation chain would not be public, the
system resolves those automatically, only the final votes remain). the unique id
for the voters would change after each vote so that it is impossible for anyone
to track voters over time yet each voter can independently verify that their
vote is in the official dump.
</p>

<p>
and that would be the gist of it. obviously as it stands there are a lot of
rough edges that need careful thought. it does not rely on any wasteful
blockchain crap though. sure, it requires a trusted central authority running
this but as long as that authority is transparent, i do not see a problem with
this. if a society cannot arrange this, then no amount of blockchain technology
can save it. if it can then the blockchain tech is not really needed.
</p>

<p>
i can see a bunch of parties starting up. the only sad part of it that although
most of them embrace blockchain as the savior of earth, they do not care much
about anonymity. or at least they are not doing good job explaining why they ask
for my name and other data and how can i be sure that it will never leak away:
linking my votes and my identity. not that i particularly care about my votes
being public or not, i just want to make sure the system gets this aspect right.
i will look out for stuff like and see how it goes.
</p>

<p>
by the way, speaking of blockchain. one of my annoyances with blockchains is
that they unnecessarily burn lot of computation away. it&apos;s wasteful. i&apos;m using a
fully central solution here. i think that&apos;s a fair tradeoff in exchange for
greater efficiency. the whole system i&apos;m describing here could run on a single
raspberry pi even for multi-million users. usually centralization happens for
saving resources. i don&apos;t have much qualms about this as long as centralized
component&apos;s scope and features are very limited.
</p>

<p>
and the actual decisionmaking might slow down, one won&apos;t be able to make
unpopular things into law since people won&apos;t vote on it. i think that&apos;s fair
compromise. if someone wants to make an unpopular change affecting the whole
population, i think it&apos;s fair that they should first convince the whole
population to want it rather than forcing it down their throat (as opposed to
convincing only a few politicians). or maybe try to convince smaller communities
to willingly canary some changes and if only try for the global change if the
canary was successful. in any case, it might not be perfect, but i think it
would make people more interested in the whole political process.
</p>
</body></html>
