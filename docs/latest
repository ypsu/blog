<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>notech.ie</title>
<style>
body {
  margin-top: 0;
  margin-bottom: 0;
}
#hcontent {
  height: 100vh;
  padding-right: 1vw;
  width: 50em;
  max-width: 98vw;
  overflow: auto;
  resize: horizontal;
}
</style>
</head><body>
<div id=hcontent>
<h1>notech.ie</h1>
<ul>
<li><a href=#goldentesting>goldentesting</a> is an alternative to a unittesting.</li>
<li><a href=#postmore>postmore</a> to keep emails shorter.</li>
<li><a href=#slowpals>slowpals</a> is about a penpals site idea.</li>
<li><a href=#mornings>mornings</a> are the most precious time.</li>
</ul>

<h2 id="goldentesting">goldentesting</h2>
<p>
ugh, i really hate unittests.
they might look nice for some trivial cases
but for modules requiring more complicated setups and dependencies
they just feel like boring busywork.
and every time i want to make a change,
i&apos;m now required to maintain the unittests too.
sure, they catch an error sometimes,
but more often i&apos;m making an intentional change,
and now i have to implement that change at multiple places.
i often dread making changes
because i don&apos;t want to deal with the weird unittests some projects have.
</p>

<p>
but here&apos;s the good news:
i firmly believe all this unittesting madness will go away
when people learn that there is a much better alternative: goldentesting.
i think that&apos;s the most common term for this.
but i heard the terms of output testing or gold master testing too.
the primary reason it&apos;s not super common yet is
that there&apos;s no good generic tooling for it.
but i&apos;m pretty sure tools will slowly get there.
though it&apos;s used in some niche areas for a very long time already.
</p>

<p>
the unittest idea is this: you write code and litter it with assertions.
the goldentest idea is this: you write code and emit text to stdout.
during code review you just need to review the diffs,
you don&apos;t need to maintain the assertions manually.
</p>

<p>
suppose you write some c++ class like this:
</p>

<pre>
  class mystring { ... };
</pre>

<p>
unittests could look like this (oversimplified):
</p>

<pre>
  int main() {
    mystring s(&quot;helló&quot;);
    assert(s.length() == 6);
    assert(s.size() == 6);
    return 0;
  }
</pre>

<p>
goldentests would look like this (oversimplified):
</p>

<pre>
  int main() {
    mystring s(&quot;helló&quot;);
    printf(&quot;%s length %d\n&quot;, s.c_str(), (int)s.length());
    printf(&quot;%s size %d\n&quot;, s.c_str(), (int)s.size());
    return 0;
  }
</pre>

<p>
running this code would then output this:
</p>

<pre>
  helló length 6
  helló size 6
</pre>

<p>
you might be inclined to commit this output next to the code,
but that&apos;s a bit spammy.
however this is where better tooling could come handy:
that tool could run the test binary at both old and new versions,
and then just present you the diff
that you and the reviewer must explicitly acknowledge before merging.
</p>

<p>
for example let&apos;s assume that some user comes along
and wants that the length() function should be unicode aware.
if you simply make the change in your code
then both unit and goldentests will fail.
the unittest will fail with an assertion
that you then have to manually fix.
the goldentest will present you this diff:
</p>

<pre>
  -helló length 6
  +helló length 5
   helló size 6
</pre>

<p>
all you and the reviewer needs to do here is to acknowledge the diff.
the commit itself doesn&apos;t need to be littered with the test changes.
after the merge, you don&apos;t need to worry about this diff anymore.
</p>

<p>
you don&apos;t even need to hardcode that &quot;helló&quot; string.
it can come from from the stdin.
then you can easily create multiple testcases
simply by running this test binary on multiple inputs.
</p>

<p>
what is the function of the tests even?
i believe there are two main functions:
increase our confidence that the code is correct,
and to catch inadvertent regressions.
i claim that goldentests can do both with greater ease.
</p>

<p>
how do you get confident that your code is correct in general?
you usually write some code and then check that it is doing the expected things.
with goldentests you pretty much stop here and commit.
with unittests you go one step further:
you add assertions for those expectations.
basically you are setting up a trap for future maintainers
to painstakingly maintain your assertions.
in the goldentests those assertions are still there
but rather in an implicit manner so it still achieves the same goals.
</p>

<p>
and they are just as effective catching regressions as the unittests.
you just need the right tooling
to enforce the same standards for goldentests as for the unittests.
</p>

<p>
goldentests scale much better for larger codebases.
suppose you are maintaining some logging library.
and now you suddenly want to change its output format.
more likely than not, in the unittest world there are assertions
that are asserting your very specific line format for some reason.
if you want to change the format,
then you have to create a massive change that changes all such tests too.
with goldentests this will just create a massive diff.
however chances are that the diff will be very redundant
and with some additional tooling (again, more tooling)
you would be able to canonicalize all the diffs
and you would end up with a small diff that you can easily inspect
and determine that your change doesn&apos;t change the logic, just the output format.
</p>

<p>
goldentests are more generic too.
for instance you could use it for compiler or linter warnings.
one of the generated output files could be warnings.
the diff tool for this would be smart enough to remove preexisting ones.
so whenever you are working on some code,
you would only see the new warnings that you introduce.
sure, sometimes a warning is wrong (otherwise it would be an error),
this method lets you acknowledge the warning and still commit,
without adding silly &quot;nolint&quot; comments to silence the warning forever.
the warning will be silenced automatically from the point of the commit.
if the reviewer thinks this is undesired,
they can ask the change&apos;s author
to add a todo to address the warning in the future.
this shines the best when you want to enable a new warning for your codebase.
you can simply enable the warning and ignore the resulting diff.
nobody will see that new warning for existing code,
so you are not adding a large burden on others suddenly.
the warning will only appear for new code which people will then address.
and the warning is still in the full generated file,
so if you want to clean up the whole codebase yourself,
you can just simply fix the existing instances one by one
and see that the number of warnings go down over time.
</p>

<p>
there&apos;s a practice of writing tests first, code later.
goldentests work for this too!
you can simply write down the expected output of your test app,
and then keep hacking at your library and test app code
until you get diff neutral.
you can write down the expected output without code or compiler.
maybe your teammate can just write down sample inputs and sample outputs,
and you can readily use that, no need to put it into assertions.
</p>

<p>
if you ever done coding competitions (acm icpc, topcoder, hackerrank)
then that environment is totally like this
and it&apos;s quite a satisfying environment,
especially when you see that your code passes all the tests.
when you solve a problem there,
you are usually pretty confident about your code.
and all they needed is some sample input and output text files.
furthermore all such testing is independent of the programming language.
with diff testing you can decide that you&apos;ll rewrite your slow python script
into some fast c++ code.
with unittesting it can be quite hard to see
that your rewrite had no effect on the logic.
with goldentesting all you need to verify is that the diffs are neutral
and then you&apos;ll be pretty much confident about your change.
</p>

<p>
at work i decided to write a little script
that parses a schedule file and outputs a nice text calendar
to visualise who is on duty and when.
actually, such calendar visualizations already existed,
what i really wanted is to visualize the diffs in a calendar
whenever someone is making a change to the schedule.
such a tool didn&apos;t exist before for these schedule files.
so i wrote a tool that parses and compares the old and new schedule files,
and then displays a calendar that has the differing days highlighted.
this is an example of one writing a special diffing tool:
most of the time the total state doesn&apos;t really matter,
all we care about is the diff.
but that&apos;s not even the point:
my point is that i didn&apos;t write any ordinary unittests for this tool.
all i did is that i hand written some sample inputs (old+new file pairs),
and just committed the generated output from them
since there&apos;s no good standard tooling for tracking golden diffs so far.
i kept adding inputs until i reached very high code coverage
as reported by the coverage tools.
when i reached that, i was confident that i handled most edge cases.
and obviously i carefully verified
that the output is what it should be for all the sample inputs.
</p>

<p>
it worked out great.
the most utility came after i released the tool
and people pointed out that i made a few wrong assumptions about the schedules.
so whenever i fixed a bug,
all i needed to do is to add a new sample input to cover that case.
or if it altered the output of an existing case,
it was very easy and obvious to see what was the effect of my change.
i usually don&apos;t get such a visceral feedback from unittests.
or sometimes people wanted me to alter the output a bit.
that was easy to do: i made formatting change
and in the diffs it was easy to see how the new format looked like.
i still love maintaining this piece of code
because it&apos;s super easy to make changes in it
while maintaining a high confidence in its correctness.
</p>

<p>
another example of such an environment would be
the deployment configs of the service of the team i worked at once.
this was a huge service consisting of many binaries running in many locations.
the system that runs these binaries needs the configuration
in a very denormalized manner.
so in the end we need to have (binaries * locations) number of configs.
to generate those configs we obviously use lot of templating.
there is a shared template
but then each binary must customize that (e.g. different cmdline arguments)
and then each location can have further customizations
(e.g. to test something in a single location only).
how would you test something like that?
you can&apos;t really.
e.g. you set a new cmdline flag for a binary to launch your new feature.
do you add a test into the configs that a flag is set?
that would be pretty dumb busywork.
what we had instead is that
for each change we just generated all the old+new denormalized configs
and then you inspected the diffs and verified
that your change does what you expected.
however on its own there would be massive diffs
just because of the sheer amount of binaries and locations we had.
e.g. you make a cmdline flag change in a binary&apos;s config
and now you have 30 files with a diff because we have 30 locations.
so we had a tool that canonicalized the diffs
(replaced references to location names with a placeholder string),
then it hashed the diffs
(just the lines with a diff, unchanged lines didn&apos;t matter),
and grouped the files into buckets based on their diff hash.
this worked out pretty nice since each cmdline flag was on their own line.
so what you actually need to do is to review a single diff
because then you can be sure that the rest of the diffs are the same.
if a single location has some special logic on the flag you are changing
and the diff looks different then that diff will go into a different bucket,
so you&apos;ll notice that too.
(sidenote: it&apos;s true that in this system weird overrides can silence some diffs,
but this could be combated with good discipline called &quot;weird needs to expire&quot;.
so all such weird overrides must have a clear deadline associated with them
at which point somebody will follow up and hopefully remove it.)
</p>

<p>
anyways, the point here is that i quite liked working in this system
simply because my confidence was very high in it.
the configuration pipeline was quite a mess
and sometimes very hard to understand,
but at least silly unittests weren&apos;t getting into my way
whenever i wanted to make a change.
i just made a change, looked at the diff,
and if if looked right, i knew it was fine.
this also made the review much much easier.
sometimes people implement quite complicated logic to achieve a thing.
but i don&apos;t really need to obsess too much about the logic itself.
all i need to look at the result and if it looks right,
i&apos;m not anxious about approving something that might be wrong.
even if it&apos;s wrong, i can see that it works for the cases we care about,
so it doesn&apos;t need to keep me up at night.
</p>

<p>
there&apos;s one caveat to this.
if you generate such a golden output,
make sure the output is deterministic and easy to diff.
if you want to output a list then sort it and output the entries line by line.
randomly ordered output would give you lots of spurious diffs
that no human can easily understand.
with too much info on a single line it&apos;s hard to see
where the diff begins and where it ends.
often you want to make a change but then see that the diff is hard to review.
to alleviate this issue, if it appears, you can just prepare another change
that changes the output such that
it will make your subsequent change easy to review.
e.g. you make change that sorts a previously unsorted list.
two small focused diffs are often much easier to review
than one larger one that does too many things at once.
</p>

<p>
however there is one significant area
where golden diffs are really lacking in tooling: interaction tests.
maybe you have some client server architecture
and you want to verify that the interactions between them look good.
here&apos;s how i imagine testing such a thing.
let&apos;s assume we want to test a client&apos;s interaction with a server.
ideally there would be a tool that can record the request/reply interations.
so first i&apos;d run my client against the real server
and i&apos;d record the interactions.
then there would be a tool that could act as a fake server
with some preconfigured request/reply behavior.
then during the test i&apos;d just assert
that the interactions against the fake server
are exactly the same as in the golden recorded interactions.
these interactions would be committed along the code,
since during the test it would infeasible to bring up that server.
if the test interactions don&apos;t match,
i&apos;d rerun the recording tool
to rerecord the interactions against the real server and commit that.
so in the review one could see how the interactions changed too.
this is quite similar to what happens in interaction unittests already
but there people manually copy paste the interactions into assertions.
in this solution that would be replaced by running a single tool.
</p>

<p>
now as with all things in life
the question between explicit asserts and implicit diffs as tests
is a question of tradeoffs.
assertions have their place too in some cases.
e.g. when you know there is no point in continuing some logic
then sure, assert it away.
and then maybe you can enforce that all tests must run successfully to end.
so basically you have a bit of both.
but i really hope that over time the tooling will improve just enough
that this idea will catch on and then hopefully life will be much easier
for code maintainers in general.
</p>

<p>
now it&apos;s true that acknowledging a diff is much easier
than painstakingly update an assertion or expectation.
so chances are that this might lead to more mistakes.
however i&apos;m not convinced that we should avoid mistakes at all costs.
rather, we should strive for an environment where mistakes are cheap.
changes should be rolled out progressively,
changes should be able to easily rolled back, and so on.
then we can focus more on the useful, new developments,
rather than doing busywork with maintaining silly assertions.
</p>

<p>
i&apos;ve tried talking with a few folks about this.
so far i managed to convince nobody about this idea.
fortunately this theory of mine would be quite easy to &quot;test&quot;.
i mean a sociological experiment on developers.
you devise a project that a person has to finish.
you make a version with goldentests and a version with unittests.
then you divide people into two groups:
one gets the goldentest one and is instructed to continue with that,
the other one gets the unittest one and is instructed to continue with that.
after the experiment you run a survey
on how easy it was to work with the project
and how confident are their about their code&apos;s correctness.
you also review the time it took to finish the project,
and also review their code to see how many mistakes they missed.
i predict that the goldentest group will take less time,
will be more confident about their code,
and the correctness rate will be just about equal.
the only problem is i&apos;m too lazy and inexperienced to run such an experiment.
i hope one day someone runs it and then we&apos;ll see if i was right or not.
</p>

<h2 id="postmore">postmore</h2>
<p>
when i partake in some philosophical email discussions,
i tend to write overly long emails.
and usually such emails contain thoughts about multiple topics.
this can be quite exhausting for the recipient to read and respond.
</p>

<p>
often those subtopics could be a blog post on their own.
while i appreciate the nuance and understanding that comes from 1:1 discussions,
there&apos;s no reason to limit ideas to two people.
ideas are meant to be exchanged!
maybe twitter was right: one should keep the direct messages short.
instead we should write more on our public spaces
and simply link them in discussions.
when a reader wants to respond, they can just write their own public post.
not responding to a public post feels less rude
than not responding to a direct message.
it feels much easier to ignore a link than a long passage of text in an email.
</p>

<p>
this is not the same as a forum discussion.
first, forum posts are in a context of a thread,
while a blog post ideally stands on its own.
you can&apos;t just write &quot;this is dumb&quot; as a post on its own.
second, you can disable comments on your own blog,
and then you&apos;ll get less responses so you&apos;ll have to worry less about them.
besides, more often than not,
comments bikeshed about the small points, or the specific metaphores you used,
rather than talking about the overall message of the post.
this then makes the comments section not a very informative place.
if one has an insightful addendum or rebuttal,
they should write a post on their own, notify the original author,
and that author should link to that post in their original post.
this is a lot more effort than comments,
but i think the resulting quality is worth the effort over the long term.
it also limits the amount of the content associated with each post
which is rather quite an underappreciated quality these days.
</p>

<p>
in other words i&apos;m suggesting that people should blog more.
sure, more posts mean less quality and more half digested ideas.
but i think that&apos;s fine, the posts don&apos;t have to be perfect.
maybe over time you learn more and completely disagree with your old posts,
or maybe even regret or are ashamed of your old posts.
i think it&apos;s still worth to keep the old posts,
so that people can see how you changed over time.
you can simply edit that old post to include links to your updated views.
eventually we&apos;ll all die and everything will be in vain,
so in the end there&apos;s nothing to lose by opening up a little bit
and writing about the thoughts swirling in one&apos;s head.
</p>

<p>
i&apos;m actually trying to convince myself to write more with this post.
i have a lot of small things
that i just want to see written down somewhere publicly.
most of them are possibly dumb things that i&apos;m somewhat reluctant to share.
but maybe i shouldn&apos;t be and i should still make a post about them
even if it&apos;s like a one sentence&apos;s worth of content.
even this post fits that criteria:
i don&apos;t really have anything interesting to say here,
and yet i&apos;m already in the 5th paragraph.
actually, this post is very similar to the freewriting i often do in notebooks.
just jotting down thoughts one after the other as they come.
now that i&apos;m doing it for a long time, i see the psychological benefits
of having a much calmer, less stressed mind in general.
so i might as well do it in the form of posts more often.
and others should write more too!
</p>

<h2 id="slowpals">slowpals</h2>
<p>
i really like discussing various ideas.
i especially like when people challenge my views
since that means i can sharpen my arguments or perhaps change my views.
</p>

<p>
however doing this in an online discussion forum is quite exhausting.
if you post something dumb in a public space,
then you get lot of responses, some of them mean even.
it&apos;s infeasible and pointless to respond to everyone.
even if you do,
you might still get another barrage of responses to any of your replies.
</p>

<p>
one solution to this is to avoid public discussions.
private discussions are often more fruitful
because you have more time and energy to focus
on really understanding that single person&apos;s perspective.
you&apos;ll be more likely be able to stand in their shoes
if this other person is open to invest the energy to make this happen.
</p>

<p>
for online discussions i believe plain text emails is a good way to discuss.
this means what you need is a good penpal finding site rather than a forum.
since one doesn&apos;t really want to reveal their email address nilly-willy,
ideally the platform would allow exchanging messages through itself.
however even with penpal sites,
it&apos;s very likely that you send a letter to someone,
and then you don&apos;t get any feedback or response to your letter,
and then you don&apos;t know if you were rude,
or if your partner just lacks the energy to respond.
ideally there would be something that incentivizes users to respond.
</p>

<p>
so here&apos;s an idea for a penpal site
that i think could be quite trivial to implement,
and requires almost no resources even.
this would an online platform that could easily scale up to millions of users
and still be operated from a small raspberry pi
because you could outsource many of its operations to free online services.
i&apos;d totally implement it myself if i knew of a couple folks that would sign up.
</p>

<p>
it would consist of two parts:
a static online site that lists all the profiles along with the profile data;
and an email address through which one can interact with the platform.
</p>

<p>
the static online site would be a plaintext document (hosted on e.g. github)
that just lists the usernames and their profile text.
i wouldn&apos;t bother with profile pics and whatnot, plaintext should be enough.
</p>

<p>
then i&apos;d have an email address, e.g. slowpals at gmail,
and the users have to register and talk to others through that address.
e.g. an user wishing to register could send an email to slowpals+admin at gmail
with a title &quot;register &lt;usename&gt;&quot; and with their profile text as the body.
then a script would process this email
and upload their profile to that online site above.
(in emails everything after + is ignored, so you can use that for such tricks.)
</p>

<p>
now comes the interesting part: exchanging messages.
suppose alice notices and likes bob&apos;s profile.
she can start a conversation by sending an email to slowpals+bob at gmail.
slowpals will then forward the email to bob&apos;s private address.
however there are three important rules that would make this interesting.
</p>

<ul><li>
  oneaday rule: you can send and receive a single message per day.
</li><li>
  replyfirst rule: you can&apos;t send or receive another message
  until you responded to your most recently received message.
</li><li>
  onethread rule: you can only have one active thread by person.
</li>
</ul>

<p>
my goal here is to artificially &quot;slow down&quot; conversations
in the hopes that they remain more civilized this way.
rather than delivering all the messages at send time,
slowpals would queue them up, and deliver them one at a time.
each user would have a first in first out queue.
so if charlie also sends a message to bob,
bob will receive the message from charlie only the next day
after he responded to alice.
and bob can expect a response from alice:
the only way to not receive one is
if alice decides to not use the site anymore.
alice will not have access to the rest of the members
until she responded to bob&apos;s email.
this also ensures that one doesn&apos;t get a barrage of emails.
one can expect that on this site one only receives a few messages,
and that one will never be overwhelmed by them.
in fact, this platform degrades gracefully:
if you stop responding, slowpals will stop nagging you,
it&apos;s as if you simply deactivated your account
and i&apos;d even delete your profile from the public listing
if you didn&apos;t respond to an email for a month.
</p>

<p>
there&apos;s one point to note:
there should be a way to end conversations
so that they don&apos;t go forever for no good reason.
it should be possible to annotate messages for which you don&apos;t expect a reply.
the same way it should be possible to report spam messages.
i&apos;m thinking of using the first line of message for optional directives.
e.g. for a message like this (involving slowpals+alice and slowpals+bob):
</p>

<pre>
  !noreply
</pre>

<pre>
  hi alice! it was nice chatting with you! cheers!
</pre>

<p>
alice wouldn&apos;t be expected to respond.
she would get this email and the next day she would get another one
regardless if she responded or not.
that day she can start a new conversation with another member instead.
</p>

<p>
note that the oneaday rule makes it hard to start new conversations
when your queue is not empty.
i think this can be considered a feature rather than a bug.
you should make the most of your existing conversations
and you should respond promptly.
most people are quite lazy when it comes to emails,
so eventually your queue would drop to zero,
which would also allow you to start new threads.
</p>

<p>
the slowness might be annoying when you start to like the other person.
however in that situation you can exchange your real email address
and you can have your discussions in real time.
</p>

<p>
and it would be quite easy to implement this site
since the email queues would be stored in gmail.
all i need is a daily cronjob that processes these emails
and forwards the messages according to the above rules.
and after i forwarded a message, i can simply delete it from gmail.
it&apos;s quite nice from the user data perspective,
since i only need to store queued emails.
the only sensitive data that needs to be carefully maintained
is the password to this gmail address and the username to email address mapping.
</p>

<p>
to keep this simple, i&apos;d probably also enforce a plaintext rule:
if you send an email with html or with attachments,
i&apos;d just simply reject your email.
i&apos;d limit the message size to 100k too.
and i&apos;d highly encourage people to strip the previous message from the body
since i really don&apos;t see the value of that in this context.
</p>

<p>
with such rules i&apos;d totally try participating in such a community.
i don&apos;t think anybody reads this blog but if you do
and you like the idea of such a penpal site then let me know.
then i might be motivated enough to build it.
or if you know that such a site already exists,
then also let me know, i might sign up.
</p>

<h2 id="mornings">mornings</h2>
<p>
i had a terrible track record of finishing anything i&apos;ve set out to do.
however i changed four things recently
and now i feel quite good about the progress on my little goals.
</p>

<p>
i often have an idea of a game or a tool that i&apos;d like to see.
sometimes i even start working on a demo for it.
but once the initial motivation is gone, i just pretty much abandon the project.
and then i feel bad about myself, and i wonder what&apos;s wrong with me.
i usually explain it &quot;ah surely work is draining my energy&quot;
and that &quot;all i need to do is retire and then i&apos;ll have energy for all this&quot;.
but then over time i started tweaking things and i&apos;ve noticed some nice changes.
in my case there are four components at play here:
</p>

<ul><li>
  scope of my goals or projects.
</li><li>
  maintaining the motivation.
</li><li>
  finding the time for the project.
</li><li>
  make project work a routine.
</li>
</ul>

<p>
scope
</p>

<p>
i had a very simple solution to the scope problem.
unless something is clearly trivial and finishable in very little time,
i changed all the goals from &quot;implement this&quot; to &quot;write a blog post about this&quot;.
now all my plans are suddenly feasible without retirement.
from past experience, writing down those ideas already give me the satisfaction
that i&apos;d get from implementing the stuff.
this is also a parenting 101 trick:
when the kid wants something that you don&apos;t want to give them,
often giving them in fantasy calms them down more than enough.
sometimes the fantasy satisfies even more than the actual reality
since everything looks and feels better in imagination.
</p>

<p>
i know some people are afraid of writing down their ideas
because they &quot;fear&quot; that other people steal them
and then make all the money that would be &quot;rightfully&quot; theirs.
for me there&apos;s nothing wrong with this.
that&apos;s actually the best outcome!
it means that the idea resonates with people
and when some other person implements it all
then it&apos;s like improving the world from an armchair without lifting a finger.
as for the money making bit:
i have a stable, good job, i don&apos;t care about the money bit.
actually, i don&apos;t even want to care about the money bit.
tbf, none of my queued up ideas are something that one could make money with.
i just wanted to mention that i wouldn&apos;t mind sharing business ideas either.
i wish other people would also be less secretive about their ideas.
sometimes it&apos;s quite hard to talk with such secretive people.
</p>

<p>
anyways, the point is that my plan is now just to write down more ideas
rather than actually try to implement them.
i have this single &quot;ideas&quot; plain text file with lots of junk in it.
with this approach i think it would be feasible for me to drain it.
it always bothered me that this file just keeps growing
and i never do anything about it.
i&apos;d totally want it to become an empty file.
if i can do that, i&apos;d feel like i reached the nirvana.
and maybe when i&apos;m old, retired and time millionaire,
i can just look at my blog posts and select some idea from there
so it&apos;s not like that the idea is lost after i got it out of my system.
</p>

<p>
however i still implement some ideas.
but only if i know it won&apos;t take ages.
ideally something that would only need a few hours, tops few days.
i tried implementing fps games in the past but then i abandoned them.
nowadays i&apos;d try to implement a single gun, and just reuse the doom maps.
so then i don&apos;t need to think about content at all,
i just need to make the existing content work with my engine,
which makes the project much smaller in scope.
makes it more achievable if i ever decide to work on something like this.
i even wrote about this idea in /shooter.
</p>

<p>
motivation
</p>

<p>
a problem with some of the longer projects is
that i eventually run out of steam.
i stop caring about the idea.
for one, my little endeavours don&apos;t really have a target audience.
there&apos;s nobody to please, there&apos;s nobody that would nag me to finish my goals.
i&apos;m aware of the idea of accountability partners, but i never tried that
because i&apos;m way too asocial to ask people to care about my silly things.
</p>

<p>
and besides, with bigger projects is often unclear when is it &quot;done&quot;.
if you work on a game and you are making everything,
you could always add one more feature, weapon, map.
or i once worked on a silly programming language
but i gave up when i had to start working on its standard library.
it felt just much work that nobody would care about anyways.
</p>

<p>
reducing the scope just enough that i can complete it in a few days helps.
then i don&apos;t need to struggle with the motivation.
however even small projects are often hard to finish
especially if i take a longer break (e.g. a vacation) in the middle of it.
when i come back, i see all the pending tasks needing completion,
and i just can&apos;t decide where to start again anymore.
it might be analysis paralysis.
</p>

<p>
i realized i need a rather softer way to get back into a project
every time i sit down to work on it.
i noticed that breaking down the tasks into trivial steps
and writing those steps down really helps.
i don&apos;t mean breaking down all the steps but just the immediate ones.
</p>

<p>
i started having a plain text file called &quot;tasks&quot; for my projects.
each line in it is a &quot;task&quot;.
there are two types of tasks:
</p>

<ul><li>
  relatively straightforward tasks that i can finish in about 10 minutes,
</li><li>
  large tasks, that need further breakdown.
</li>
</ul>

<p>
to keep the format simple, i just simply prefix the latter tasks with &apos;!&apos;.
when i start out a project, i map out all the tasks i plan to do,
generally in the form of large tasks.
i then break the tasks down into smaller ones as i go.
e.g. for this blog post i could for instance have the following tasks:
</p>

<ul><li>
  mention analysis paralysis
</li><li>
  mention task types
</li><li>
  explain how i process the tasks
</li><li>
  ! explain the time component
</li><li>
  ! explain the routine component
</li>
</ul>

<p>
then i just go from top to the bottom and work on the tasks.
if the topmost task is a large (!) task,
then my task is to break it down and replace it with smaller tasks,
that i&apos;m actually capable of doing almost any time.
as you can see in the above example, the topmost tasks are simple ones.
</p>

<p>
in the old times i tried to juggle the breakdown in my head.
however being explicit about this really helps.
especially being methodical about going from top to bottom,
i no longer feel paralysed by the remaining work,
since i can see the end right in front of me.
and i don&apos;t really need to think hard about the next item
to tackle at any given moment since that&apos;s given too.
and it&apos;s quite satisfying to see the todo items disappearing
as i&apos;m committing my changes.
all i need now is to give the project some dedicated time.
if i do that, then i certainly make progress,
and making progress is often quite motivating on its own.
</p>

<p>
time
</p>

<p>
i believe that the time aspect was one of the most crucial aspects for me.
i tried to work on my hobby projects either on the weekends
or the evenings after work.
but the time available for me was very spotty.
the weekend usually didn&apos;t work out since i had to tend my family.
in fact tending my family even frustrated me a bit
since i couldn&apos;t use that time for my own stuff.
the evenings didn&apos;t really work out reliably either.
my kid goes to bed at somewhat random time
which means some days i have more time, some days i have less,
and that was frustrating.
especially if i have less time remaining, i don&apos;t feel like starting anything
since i feel that i won&apos;t be able to achieve anything.
and besides, by the end of the day i was tired,
i was at the lowest &quot;energy levels&quot;, least motivated.
</p>

<p>
when my motivation was very high,
i did manage to make some progress in the evenings and on some lucky weekends,
but i did not make steady progress, it was just sporadic progress.
i thought that my official work is my primary blocker here,
and that if i retired, i&apos;d be able to work on these things.
all i need is just struggle through my work years.
i was wrong.
</p>

<p>
earlier this year i decided to track my myopia progression.
this entails me regularly measuring my focus reach with a measuring tape.
later i&apos;ll write a post about this
but for now the point is that i had a developed a regular habit.
initially, while the motivation was high. i measured multiple times a day.
then once i got the technique and the logging mechanics down,
i wanted to minimize the time i spend on this,
so i decided that i&apos;d measure myself once daily.
</p>

<p>
i&apos;ve set up a little daily reminder for myself
(see the reminder file in my /task post for my reminder mechanics).
so basically this reminder was the first thing i&apos;ve seen each morning,
which meant it was the first thing i did
whenever i first sat down in front of my machine.
i&apos;ve noticed that doing this little thing each morning wasn&apos;t a big effort.
</p>

<p>
later this year i got a new keyboard with a new layout (see my /kbd post).
i decided to track my typing speed once a day in the morning too.
so each morning i measured my eyes and my typing speed.
those were my &quot;dailies&quot;.
i found it actually quite nice to have something &quot;done&quot; each day.
and i could do this even on the weekend mornings
if i decided to wake up before everyone else.
so i decided to wake up around 6am every day or a bit sooner if i could manage.
in the summer times it&apos;s easier for me to wake up earlier thanks to the sun.
but this meant i couldn&apos;t stay up too late,
so i started having a &quot;go to bed alarm&quot; too and i went to bed at 10pm every day.
</p>

<p>
so there i was, up early in the morning and i could see from my apartment window
that all the other people were still sleeping.
it was quite a nice feeling being awake alone in the world.
it felt like the right &quot;me time&quot;.
it felt like this is the time i should be doing something productive.
so i decided to use these mornings to make progress on my personal projects.
</p>

<p>
it worked out great.
it turns out i&apos;m a morning person, mornings is when i have to most energy,
morning is when my motivation is at the highest levels.
and in the mornings i have more time flexibility too.
if i need a few more minutes to finish something,
i just start my work a bit later.
in the time of the work from home this is quite easy to achieve.
</p>

<p>
routine
</p>

<p>
i started doing this morning ritual for my todo items
when i was setting up a new raspberry pi for my new eink screen.
this contained lot of tasks, including tweaking xterm source
so that it completely ignores colors on this machine.
delving into a foreign codebase is a bit scary for me,
but breaking down the tasks into very manageable pieces like
&quot;download the source&quot;, &quot;build it&quot;, &quot;make it work&quot;, &quot;grep for color&quot;, etc
really helped to maintain momentum.
and i did all this before checking my emails or todo items for the day.
avoiding the reality in the morning helped me to focus on my tasks,
i wouldn&apos;t start obsessing about the daily churn that i have in front of me.
</p>

<p>
once i was done with the setup,
i decided to use my mornings to finish /peckmania.
that worked out great too.
then i decided to make a tool for myself to better manage my issues at work.
it worked greatly, i managed to finish what i&apos;ve set to.
working on small little projects in the mornings became a routine.
i&apos;m writing this post in the mornings too.
</p>

<p>
and it was a good routine:
it meant that every morning i achieved something, even if a little thing.
it also lightened my mood, i felt a bit more productive at work too.
i no longer had &quot;zero days&quot; where i achieved absolutely nothing
which usually led to feeling a bit sad afterwards.
if i missed a morning, i felt an uneasiness until i did my dailies.
</p>

<p>
there&apos;s another thing that really helped to not break the routine so far:
not trying to do large things in parallel.
if i want to read a book, watch through a tv show, play a video game,
now i queue it up as &quot;project&quot;.
i just consume such things after i finished my current project.
and i do them primarily in the morning.
this way i have much fewer regretful thoughts about
what i should be doing instead while binge watching a new anime.
i know that i can enjoy that show or game without regret,
since i&apos;m between little projects,
so it&apos;s like a mini holiday that i earned for myself.
</p>

<p>
eventually i picked up a few more routine habits over time.
since i&apos;m in switzerland, i feel like i should have some german comprehension.
therefore i&apos;m reading a page or two of german text every morning
and then look up and write down all the unknown words i encounter in it.
i use the online linguee site for this and with my eink screen it&apos;s quite nice
that i still don&apos;t actually have to look at some bright screen in the morning.
my computer time in the morning is almost like reading a book.
hopefully over time this will improve my german vocabulary
and i&apos;ll be able to navigate this german world a little bit better.
actually this became the first routine i do in the morning,
since some slow reading and writing is a very nice way to wake up.
</p>

<p>
in the old times, while i lived in dublin, i used to walk a lot every day.
that&apos;s no longer true in zürich, especially now with all the work from home.
so i decided to reinstate some morning walks in the nearby small forest.
the fresh morning air is very nice.
i just wish the forest was bigger so that i could walk more.
</p>

<p>
i also changed my evening structure.
in the old days i just used to watch youtube or read the internet
until i got bored and went to bed.
for one, i now go to bed at 22:00 quite punctually.
but before that i try to avoid the computer from 20:00 or so.
i just take my notebook and freeform write into it
about anything that comes to my mind, basically reflecting.
i just really like the feeling of freewriting.
this usually involves thinking about future plans and what i should be doing.
a lot of good things have come out of this.
i decided to do that german reading practice
after hours of thinking what easy and fun thing i could do to learn some german.
even deciding to start walking again was thanks to a lot of reflecting.
without all this reflecting i feel like i&apos;m on autopilot
and never really consider trying new things, so i really need it.
another benefit of just simply writing rather than consuming something is
that it helps me start feeling tired sooner which in turn helps fall asleep.
</p>

<p>
though i&apos;d add that this doesn&apos;t mean that i never procrastinate.
sure, i do that when at work and i&apos;m unsure what to do.
however i don&apos;t procrastinate in the mornings,
and that&apos;s the important point here.
</p>

<p>
effect
</p>

<p>
when i add together all the things i mentioned above, they do magic for me.
i think if i were to take to away any component, my system would fall apart.
but thanks to them, i feel quite good about my days,
i no longer feel that &quot;only if i&apos;d retire, could i really achieve my goals&quot;.
progress towards one&apos;s goals can be made anytime with the right habits.
one just need to find them with lots of reflection.
</p>
<hr><p>the rest of the entries can be found at
<a href=https://html.notech.ie>html.notech.ie</a>.</p>
</div></body></html>
