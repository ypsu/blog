<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>notech.ie</title>
</head><body>
<h1>notech.ie</h1>
<ul>
<li><a href="#task">/task</a> management must be done carefully.</li>
<li><a href="#liquid">/liquid</a> democracy is a neat idea.</li>
<li><a href="#fsbuf">/fsbuf</a> are my notes about filesystem buffering.</li>
<li><a href="#codeswap">/codeswap</a> describes how would i compare software design styles.</li>
</ul>

<h2 id="task">task</h2>
<p>
like most folks i also have a barrage of ideas, requests, commitments, chores
and so on that i just need to do. since i don&apos;t have perfect memory, i need a
system for managing them. every person manages this differently: some just rely
on their memory, some use sticky notes, some use elaborate software, some use
bullet journaling, and so on. there&apos;s no system that works for everyone. i&apos;ll
now share what works for me.
</p>

<p>
first it&apos;s important to define what your end goal is. a typical goal is &quot;to be
productive&quot;. that doesn&apos;t work for me. i don&apos;t care much about productivity. my
primary goal is to become &quot;free&quot; - free of the tasks. ideally my todo list is
completely empty. if it&apos;s empty then it means i&apos;m pretty much free to do
whatever i feel like doing. that is usually daydreaming which usually leads to
bunch of new ideas which then fills todo list again. so even though the todo
list doesn&apos;t stay empty for long, it&apos;s super important to be able to
occasionally achieve 0 outstanding todo items. if i can&apos;t achieve that, then
that is a singal to me that i&apos;m doing something wrong and i need to sit down and
holistically reevaluate my priorities. keeping the todo list near empty means
you can be more flexible, can easily change directions, try new things, be super
responsive to people without feeling much dread about all the tasks you need to
do. but near 0 outstanding tasks is super hard to achieve regularly. however one
can create the illusion of low task load simply by hiding majority of the tasks!
not all tasks are the same. i&apos;m not really fond of hierarchies or labeling
things but i do have 4 categories for my tasks:
</p>

<ul><li>
  conditional tasks
</li><li>
  stashed tasks
</li><li>
  queued tasks
</li><li>
  archived tasks
</li>
</ul>

<p>
conditional tasks are the best! those are tasks that you want to do but you
can&apos;t. suppose you need to talk to a person about a topic but that person is
traveling. you can&apos;t talk to him until they come back. it means this &quot;talk to
person x&quot; task has a date condition. you just need to hide the task until a
specific date. or you want to remember that you need to do a regular, yearly
maintenance on your car. you can just add a task that is triggered on a certain
day of the year. you&apos;ll see the task in your todo list from that day on until
you clear the task. once you complete that task, you readd the condition to the
task but with the year bumped.
</p>

<p>
one might use a calendar for this. however that is wrong! the problem with the
calendar is that you&apos;ll see all the upcoming tasks if you look at a weekly or
monthly view of the calendar. if you see the task, you&apos;ll remember that you&apos;ll
need to do it at some point and you might start stressing about the upcoming
burden. and it&apos;s all pointless because you might not be able to act on the task
since its trigger date has not passed yet. it&apos;s really important to keep the
conditional task hidden until it&apos;s triggered. surprisingly many tasks can be
hidden simply behind a date.
</p>

<p>
on my personal computer i have a &quot;.rems&quot; file standing for &quot;reminders&quot;. each
line in it has the format of &quot;yyyy-mm-dd some arbitrary text&quot;. you might notice
that the filename starts with a dot which means it&apos;s a hidden file. i don&apos;t want
to be aware of this file. most of the entries from it shouldn&apos;t be triggering,
so i shouldn&apos;t care or know about them at all anyways. i also have a &quot;todo&quot;
script which prints a portion of this reminders file (among other things like
checking my email). it prints the lines whose date is in the past. i run my todo
script occasionally, yet most of the tasks from the reminders file stay hidden
until they are actionable by me. i can completely forget about those tasks and
still remain calm that i&apos;ll see them in time (unlike the calendar where i&apos;d see
the tasks all the time).
</p>

<p>
furthermore in certain environments one can be even smarter about this. at work
we have a relatively simple issue tracking system. each issue can have an
assignee field. if you have an issue assigned to you, you are expected to do
something about it. fortunately we have a nice robot to which you can reassign
these issues with a condition. you can tell it &quot;please assign this back to me
once that other issue is fixed&quot; or &quot;please mark this as fixed once that commit
is pushed&quot; or &quot;please assign this to person foo when person bar is back from
vacation&quot; and gazillion other actions and conditions. if you use this robot
well, you can hide a lot of your unactionable tasks. suppose you have an issue
assigned about a bug to you and you already created a commit to fix it and sent
it to review. at this point you can&apos;t do much about the issue, you are waiting
for the other person. so you tell the robot to keep the issue hidden until the
bugfix is pushed. after the review you push the commit. at that point the issue
reappears and you can, say, send out an announcement that you fixed the bug and
close the issue. having the issue hidden means cleaner dashboards, smaller todo
lists, and simply less mental tax. i love this tool at work and use it to keep
my work task count quite small compared to the rest of my colleagues.
</p>

<p>
you can also use conditionality to spread out tasks. one example is when you
have multiple issues that you have to solve in order. you can use the above
robot just to chain them up and in any given moment you&apos;ll only see the first
issue that you need to work on. once you close that, the next one appears
immediately. it makes work much streamlined - you always know what to work on.
this trick also works for unrelated tasks. there&apos;s only so many things you can
do at any given moment. you can decide that you create some sort of order over
the tasks based on importance and chain them based on that. for instance there&apos;s
a person i like to chat with and i always come across topics or ideas that i&apos;d
like to talk about or just get their general opinion on. but if they are
traveling i can&apos;t talk to them. at the same time i don&apos;t want to forget the
topics. i also can&apos;t talk about all the topics with them at the same time when
they come back. so in such cases i just chain the topics. i mark the first topic
to appear in my todo list once they are back and keep it there until i managed
have a talk about it. after the talk i go back to my machine and cross it out
and the next one appears - which i&apos;ll remember the next time i meet them. it&apos;s a
pretty simple way to keep many things in your todo list without being overloaded
by them.
</p>

<p>
there&apos;s one additional benefit of the conditional tasks. the conditions
themselves also serve as a communicational tool. it communicates what a task is
waiting on. so if somebody is getting impatient with a task&apos;s state, they don&apos;t
need to bug you, but they can look and challenge the condition directly. e.g. if
an issue is waiting on a commit and the commit is waiting for a reviewer, then
they can ask the reviewer directly when are they going to finish the review.
</p>

<p>
my next big category is the &quot;stashed tasks&quot; one. some people call these the
iceboxed issues. a lot of times a random idea comes to my mind that i&apos;d really
like to do, investigate, experiment with further. however often such tasks are
not super urgent or important. i just want to be sure i don&apos;t forget about them
until i completed said task. sometimes i want to keep a thread of thought open
somewhere until i make my mind up about something. basically these are tasks
that i want to track but not to be reminded about. since i don&apos;t look at this
list proactively, this list tends to contain a huge number of tasks. but that&apos;s
fine. i encounter many ideas day to day. if i don&apos;t write them down into a safe
place, i tend to obsess about the idea a bit because my brain doesn&apos;t want to
let go of it until it senses some sort of closure. writing it down to my stashed
tasks lists gives it that closure.
</p>

<p>
ideally this list shouldn&apos;t be growing unbounded. it would be only consulted
when the primary todo list becomes empty just to find new things to do or when i
left some notes about some particular topic which i now want to look up. if i&apos;m
looking at it because i don&apos;t have better things to do then i can either do some
of the tasks i always wanted, or just clean up old, irrelevant entries from the
stashed tasklist. one always feels pretty good after such a cleanup.
</p>

<p>
i implement this by having a simple &quot;.ideas&quot; free-form text file on my computer.
i just randomly add stuff to it whenever i think of something. it&apos;s also a
hidden file since i want to keep it out of sight. i do have a little structure
to this file since it is quite long. each task has a title and i prepend a &quot;#&quot;
sign for those titles. the subsequent lines are the notes related to the task.
the nice thing is that this way i can have a quick overview of all my stashed
tasks simply by running &quot;grep ^# .ideas&quot;. i don&apos;t use more structure than this.
</p>

<p>
at my work there are several ways to achieve stashed tasks. the issue tracking
system actually supports two levels of assignments: &quot;assigned&quot; and &quot;accepted&quot;.
in theory you can assign any issue to anyone and the other person should mark
the bug as accepted once they plan to work on it. so technically you could use
&quot;assigned&quot; for the stashed work and &quot;accepted&quot; for the work you actually want to
work on immediately. however this distinction is not well understood, recognized
or used so even though i could use it personally, i don&apos;t do it. in fact, i try
to avoid stashed tasks at work completely. if i have such work related
unimportant idea, i write it to my personal .ideas file. at work i&apos;d just simply
close or unassign such an issue. this clearly and unambiguously signals to other
people that i do not plan to work on an issue. you can also add issues to a
&quot;hotlist&quot;. basically it&apos;s like twitter hashtagging but for issues. you can add
arbitrary issues into arbitrary hotlists. e.g. you could create a &quot;my stashed
issues&quot; or &quot;icebox&quot; hotlist, and just add issues of interest into that. you can
keep the issues unassigned so people who want to see the status of an issue can
clearly see that nobody is working on it. this approach also works on a team
level. if a team wants to track some issues but not work on them, they can hoard
them in such an icebox hotlist. generally speaking such hoarding is not very
healthy but it can make people feel calmer due to having a place to gather
thoughts about certain issues.
</p>

<p>
when one works with documents or source code, they can also leave todo comments
in the middle of the document. it&apos;s a very low overhead way of tracking tasks.
at my work they have the form &quot;todo(username): some text&quot; or &quot;todo(issue/12345):
some text&quot;. i&apos;d treat &quot;todo(username)&quot; as a queued task (will explain shortly)
however &quot;todo(issue/12345)&quot; is less clear. if issue/12345 is a stashed task then
that todo comment task can be treated pretty much as stashed as well. you can
think of these as mini-issues that block the main issue. at my work we even have
a cronjob that periodically crawles the whole source tree looking for such
comments and marks such occurrences in the linked issue. for each issue people
can see all the outstanding blocking issues and todo comments as well. they
shouldn&apos;t close the issue until they clean those up. in fact they receive a
warning notification if they close an issue nevertheless. but the point is that
you can keep tasks right in your primary work documents as long as you have the
tooling to manage them.
</p>

<p>
next up are the queued tasks or active tasks. these are the tasks that you think
you&apos;ll be able to work on in the next few days. you really should keep this very
short. in a perfect environment without disruptions you should be able to finish
all of them within a week. if you can&apos;t because you have so much or so big items
on this list, then the list is pretty much useless. it&apos;s useless because then
there are tasks on it that will be never addressed, basically tasks that should
be stashed. however just because they are in your active tasks you&apos;ll see them
every day. you very quickly start to ignore those items. if you ignore one item,
you&apos;ll very quickly start to ignore other items. this then snowballs: you pretty
much don&apos;t even use this list to guide what you should be working on next. it
just drags you down mentally, reminding you that you&apos;ll never be able to reach
the nirvana of 0 tasks. this is why i prefer the term &quot;queued&quot; tasks. it means
you can&apos;t allow things to linger in this list. if possible, you should go
through the tasks in fifo manner - first in, first out, no matter what the task
is. even though it might not sound a super productive strategy but it builds a
good habit of not hoarding tasks. i often have some very small idea i want to
try. before i forced myself to use the fifo rule, i pretty much procrastinated
on such ideas and eventually even dropped them because i got bored by hoarding
them in my todo list. with the fifo rule, i&apos;m forced to be more exploratory and
i actually learn ton of new stuff this way. simply because i force myself to
work on or explore the random unrelated ideas i queue up in my active tasklist.
</p>

<p>
it&apos;s super important to keep this list realistic. only put stuff into that
you&apos;ll actually get to in the order of days. there&apos;s on exception: if your task
is big, then it&apos;s okay to keep an entry about it in there as long as you chip
away at the task every day. you can also put untriaged items into this list. for
example you can treat reading your unread email as your queued tasks. some
emails might prompt for additional investigation, you might keep this email in
your queued tasks until you figure out how to respond to it. the task itself is
the fact that you have to figure out the response.
</p>

<p>
you can even try some psychological tricks to reduce the number of tasks. a lot
of my personally generated tasks are just ideas that i really want to explore
and experiment with. you could save some time yourself if rather than just
jumping right into implementing the demo, you talk about the idea with someone
first. this means the task now is not implementing stuff which can take long
time and requires a lot of motivation to start, but rather just having a chat
about it with your buddy. basically transform the task to scheduling a meeting
with your buddy. the original task becomes conditional - the condition is a date
that is after your meeting. this is also a great way to get out of your comfort
zone and make yourself talk to other people. all being motivated from the fact
that you want to keep your queued tasklist small. and not only that, you might
even learn new things. your buddy might point to an already existing thing, give
you tips on how to simplify things and so on. there&apos;s not much to lose from this
trick.
</p>

<p>
management of these tasks should be relatively low overhead. different kinds of
tasks need different tools for optimal maintenance. my first tool is an
unstructured &quot;todo&quot; file on my computer. i just queue stuff to the end, and pop
stuff from the top. popping the top is not a strict rule, but just an ambition.
most of my own ideas land in this file. often i write an idea down there, and
once i&apos;m done with the initial brainstorming, i just move it to the stashed
tasks. however i might not always have an access to my machine. in those case
i&apos;ll open a draft email in my gmail. gmail adds a quite visible marker if you
have a draft so i&apos;m always aware of my drafts. however i strive to move my
drafts to my todo file from above once i get back to my personal computer. i do
this just to reduce the amount of places i have my tasks.
</p>

<p>
note that this &quot;todo&quot; file doesn&apos;t start with a dot - it&apos;s not hidden. making
this file present in my home directory reminds me that i have stuff to do. if it
were empty, i could just delete it. actually all non-hidden files and
directories in my home directory mean some form of outstanding item for me. if i
start working on a demo or experiment, i just create a directory for it in my
home directory and keep it there until i&apos;m finished with it. then i just either
delete it or move it to my &quot;.d&quot; hidden directory which contains all sorts of
random stuff. stuff that i need to keep around (e.g. a checkout of my dotfiles
git repo) or various random stashed things. &quot;d&quot; stands for &quot;drive&quot; or &quot;disk&quot;
suggesting i archive most large things under that directory. if i want to keep
something around for later work, i make a note of it in my stashed tasklist, and
move it to my &quot;.d&quot; dir. if i want to pick it up again, i can just either move it
back or simply symlink the directory from my home.
</p>

<p>
the next big source of active tasks are the email messages. email management is
a huge topic on its own, i probably can&apos;t do much justice to it. but let me try
to give it a short summary. there are 4 kinds of emails:
</p>

<ul><li>
  an actual conversation you have with someone,
</li><li>
  a notification of something personally relevant to you,
</li><li>
  a feed item, news, random chatter,
</li><li>
  items of interests that you won&apos;t read but want them to be available when you
  look or search for them.
</li>
</ul>

<p>
the first two categories are fine with me, i&apos;m happy to receive them since they
usually mean that i have to act on them. i don&apos;t have the 4th item at all. i
unsubscribe for all unnecessary updates and alerts. if i don&apos;t read it, i won&apos;t
know i can search for it anyways. at work usually such mails go to google groups
archives too so i can just use google groups search to find such emails. i&apos;m
quite strict about the third category. i subscribe only to a very few and
relevant feeds. if the feed only has an occasional post then it&apos;s not bothering
me. if it&apos;s high volume then i try to make it less high volume by trying to
eliminate unnecessary spam from it right at the source (e.g. i ask the robots to
stop spamming). if that doesn&apos;t work, i just change google groups to send
updates in bulk (so my inbox can remain clean) or just unsubscribe entirely and
remind myself to check on the group occasionally. i either just rely on my
memory to check on the feed - if i forget then it&apos;s probably not that
interesting anyways, so it&apos;s a good riddance and i can enjoy the additional free
time i got by not reading the feed. or i might add a date conditioned task to
check back on the group - usually for work related stuff i ought to know about.
but i try to keep these to the minimum. but it&apos;s all a moot discussion since
these don&apos;t generate tasks for me unless it&apos;s a list that i&apos;m supposed to give
support on.
</p>

<p>
anyways, let&apos;s get back to the main topic. whenever i see something in my inbox
that needs some further action or thought from me, i just simply star it.
starred emails are also part of my queued tasks. it might be the case that such
an email is either just good but long thread that i don&apos;t have the time to read
now, or it&apos;s blocked on something. in those case my action for that starred
email is to make a note of it in either my stashed or in my conditional
tasklists and then simply unstar it. that&apos;s pretty much my workflow: i read all
my email, i star the things i need to something about, and then when i have
time, i address the starred items. again, i actually follow up on those emails
quite quickly, i don&apos;t hoard them.
</p>

<p>
i also consider issues assigned to me as my active tasks. i either actively work
on them, or just reassign them either to someone more knowledgeable or to the
robot in case it&apos;s blocked on something. one annoyance with the issue tracking
system that most updates generate an email to every person cc&apos;d on the issue.
however fortunately my work&apos;s issue tracking system allows editing some of the
comment updates: you can edit your own comments and the issue&apos;s first comment.
these edits don&apos;t generate an email notification. so you can pretty much keep
updating an issue&apos;s first commit to match the &quot;explain the issue; explain the
status; make note of outstanding tasks&quot; format there. and then you make it a
personal habit to check and update the first comment before closing an issue.
</p>

<p>
the next tool i use is our internal code review tool. each commit has an author
and a set of reviewers. usually the author and the reviewers exchange comments
and changes until everybody is happy with the commit which is then pushed. the
tool itself has a very handy &quot;attention tag&quot; feature to manage whose turn it is
to respond. it&apos;s a boolean flag on the author and each reviewer. when the author
sends out the review request, the attention is on the reviewers. when the
reviewers respond, the attention moves to the author. people can flip the
attention on the individuals manually but by default the tool is quite smart
with managing it automatically. whenever i have the attention for a commit, a
small browser extension starts glowing. by default it is gray so when it
switches to a bright color, i notice that quite quickly but doesn&apos;t interrupt me
in any way in case i&apos;m in the flow. if a commit has my attention, i treat it as
my active task and my goal is to review the commit or respond to the comments
depending whether i&apos;m the author or a reviewer. even when i&apos;m the author of a
commit, once i send it out for review, it pretty much disappears from my active
tasks and i can immediately focus on other things. note that i can send the
review request to a robot along with a condition here too. the robot will keep
the attention tag on itself until the condition is true. then it assigns back
the attention and leaves the review thread. this gamified workflow of attention
tag ping-ponging makes it very gratifying to stay on top of the review workflow.
</p>

<p>
so those are my main channels for the active tasks. again, it&apos;s super important
to ensure you treat them in timely manner. in fact, it&apos;s best if you commit that
every day you&apos;ll start your day by addressing or making progress on your oldest
item from your queued tasks. the benefit of doing this is that you always have a
clear task to start the day with. once you do that, you&apos;ll feel that you
achieved something, and you&apos;ll be even more motivated to do more things rather
than just procrastinating all day on the internet. however in order for this to
work, your tasks in this list must be crystal clear rather than vague. if you
have a task which is unclear on how to solve, then your task is to figure out
how to solve it. most of the time it means writing to a support list or just
scheduling a meeting with your mentor or buddy to give you guidance. reaching
out to a person is always relatively easy, so you should always be able to do at
least that, no matter what the task is.
</p>

<p>
next up is the archival of tasks. i neglect this most of the time. however now
and then i want to be able to remember that i did something and how i did
something. i want to be able to refer back to my old notes. i don&apos;t worry about
this at work because the issue tracking system will keep all the notes and
comments around viewable by anyone. the more interesting question is what to do
with the completed personal tasks. the simplest thing to do this is just to have
a private journal. every time something comes up, you just append a note to the
end. in fact, i hear that doing daily journaling is quite healthy for one&apos;s
wellbeing. sometimes if i&apos;m in the mood, i do write some notes about every day.
but i quickly run out of steam. but if some important happens, i usually always
add it to my journal. i keep a &quot;.notes&quot; file in my machine and just write to it.
every new year i rotate this notes file. i just put the contents of the journal
into an email and send it to my email address. this way i don&apos;t have an ever
growing file on my machine and i can easily refer back to my notes via the email
interface&apos;s search facilities.
</p>

<p>
there are other ways to archive tasks and ideas. one way is to write about them
to someone. if i learn about a nice idea or nice article, i often just send it
to a buddy along with some personal comments. one, this sometimes starts a nice
discussion, two, i can easily refer back on the letter later. the benefit of
doing this over the journal is that it&apos;s much easier to remember about this
because you also talked about it with the other person. so even if you can&apos;t
remember how to find your notes or article again, you might remember who you
talked to about it, and just ask them if they remember anything. basically you
are outsourcing your memory to other people. it&apos;s also a nice way to keep some
social interactions alive.
</p>

<p>
another alternative is to write a public blog post about the idea. i think this
is one the best things you can do if you have the guts to publish stuff online.
this forces you think about things very carefully, forces you clear up your
thoughts so that they can be put into words. and if you are not shy, you can
even share the post with others. once it&apos;s published, you can pretty much forget
about the idea, unless others come back to you and become interested in your
specific idea. it can also act as a nice survey to see how good an idea is. if
people don&apos;t seem to show interest after you show it to them, maybe it&apos;s not
worth pursuing it. if they do, that interest can actually act as a motivation to
start working on the demo. having said that, i don&apos;t popularize my blog. i write
a lot of crap here that might be better if people wouldn&apos;t know about me. maybe
when i&apos;m older, this will become easier and i won&apos;t care about all this. it
would be awesome if people would ask me about my posts after i wrote them
though. but i don&apos;t want to keep notifying them about my posts - i want them to
learn about the posts because they are interested in the posts and explicitly
started following me. i want genuine interest rather than pleasantries. but for
that i&apos;d need to learn to write interesting posts, but let&apos;s postpone acquiring
that skill for a later day.
</p>

<p>
having said all that, there&apos;s no reason you can archive a task only in one
place. you could write a post, share it with a friend, and then finally mention
it in your journal. in fact, that would be probably the ideal habit if you have
the grit for it.
</p>

<p>
if you see some very old tasks in the stashed lists, then they are very good
candidates for archival. in fact often it&apos;s best just simply decide not to do
some tasks. give some thoughts about it, write down how you would go about them,
publish them on the blog, and then just forget about them. at least this way you
give yourself the closure that you gave the idea some attention but still didn&apos;t
waste too much time on it. and since it&apos;s on your blog, you know you can always
refer back to it from anywhere if you feel nostalgic about an idea. or just
point to your blog entry whenever you see somebody else thinking of a similar
idea. ask them to take a look at yours to see if they can use that as an
inspiration.
</p>

<p>
anyways, that&apos;s pretty much how i manage my tasks currently. although i wrote
quite a lot and i need custom tooling, i think my system is relatively simple -
mostly consisting of 3-4 unstructured text files for most cases. i wrote a lot
because the system is quite powerful and needs lot of explanation to explain
said powers. i&apos;ve seen more complicated systems used by people which eventually
turned out to not being very effective for them. especially after they ran out
of steam maintaining the required process or structure. task management must be
low overhead. and i&apos;d reiterate again, task management won&apos;t get you out of
unproductivity and procrastination. i&apos;m not using this for that purpose. i&apos;m
using this system simply for tracking and making an order of my outstanding
tasks and ideas in a relatively low-overhead but featureful system. although i
haven&apos;t tried, a similar method can scale up for teams as well, not just for
individuals, it just needs careful thought. i&apos;ll spare the speculation about
this aspect for now though. i&apos;m still relatively new to managing my tasks this
way (couple months) but let&apos;s see if it crumbles down or not.
</p>

<h2 id="liquid">liquid</h2>
<p>
i always had problems with politics and voting. my problem with today&apos;s form is
that the system is way too simplistic and rigid. in the end the choice usually
boils down to choosing between two parties, the one you hate less. then wait and
hope things do not go way too bad. this is a false choice to me. i feel
completely disconnected from the process and therefore i feel like abstaining
until i see a better alternative.
</p>

<p>
i came across the liquid democracy idea which is pretty neat. i will not go too
deep into the details or merits of the idea but the main idea is that people can
vote on directly on the issues or appoint delegates that can vote on their
behalf in issues related to specific topics. people can change these delegations
at any moment. this makes campaign circus every 4 years somewhat obsolete which
is also a nice benefit.
</p>

<p>
it is also important to note that it is actually quite easy to migrate to a
democracy like this if people wish so. one can create party that provides the
above system and then commits to vote in the office according to the people&apos;s
wishes. if a person wants to vote for party x, they could still vote for this
proxy party and in the system they would set their preferences to follow party
x&apos;s votes. i understand politics is more than just voting but for the sake of
brevity i only want to focus on this part for now.
</p>

<p>
there is only one problem with this idea: it is not obvious how to maintain
anonymity in this system. i did a quick internet search but did not find much
discussion around the topic. i did find a lot of blockchain mumbo jumbo as if it
would solve anything in this aspect of the problem. or the other things i found
was questioning this feature of democracy which is also quite absurd. i am sure
there are lot of good solutions to this but before searching deeper, i like to
give it a thought of my own: how would i reinvent things with zero practical
knowledge. writing down just helps me make the ideas more concrete. i will get
everything wrong but at i might learn something out of this when i am reading
about serious solutions.
</p>

<p>
my system would have couple important concepts:
</p>

<ul><li>
  public profile: this is a person whose identity is publicly known and their
  votes are publicly visible for accountability. these people would be the
  &quot;politicians&quot; who would be publicly standing up for various things. anybody
  could register as a public person. voters can delegate votes only to public
  people.
</li><li>
  private profile: this is a user in the system without an identity attached.
  they can vote directly or delegate votes to public profiles. this is what most
  people would register as.
</li><li>
  issues: this is what people can vote on. you have a question and a list of
  outcomes that people can vote on. there would always be an option for
  abstaining, and also for marking the question as invalid or false choice. i am
  not sure about the voting algorithm though: i am vacillating between approval
  voting and instant runoff voting with optional preferences. i like the former
  for its simplicity. on the other hand the latter has even better properties at
  the cost of much harder decisionmaking at the voting time.
</li><li>
  tree of topics: each issue must belong to a specific topic. and each topic
  must belong to a parent topic (there would be a root topic). this is only
  needed for categorizing the questions for the convenience of delegations.
  think of topics as directories, issues as files in those directories if that
  makes it any simpler.
</li>
</ul>

<p>
had i a website for this, i would not allow much discussion to happen on the
site other than casting the votes. this way there is no need for moderation
which can avoid a lot of problems and makes the site lightweight. as to where
the votable issues coming from: that is a bit outside scope of this brainfart
but the general gist is that it would go through formal channels and the only
people that can suggest votable issues are the people who then agree to be held
accountable for the outcomes.
</p>

<p>
one familiar with the concepts of liquid democracy can probably already imagine
how one could create a system using the above concepts: after people log in,
they can see issues, cast their votes directly, or set up delegations to public
profiles for specific topics (e.g. healthcare, education, or just
education/highschoolers). they also see their historical votes, and what
delegation chain led to that vote if any.
</p>

<p>
however two issues remain: how to ensure one person can have only one account
and how can someone verify that their vote counted.
</p>

<p>
i assume that the country already has a way to uniquely identify its citizens
with some sort of official id card. i imagine this algorithm after i decided
that i want to participate in the voting anonymously:
</p>

<ul><li>
  i go to an official registration office where i show my id card and i receive
  a ticket in exchange.
</li><li>
  with the ticket i can register into the online system from home and
  participate in the votes for a limited time.
</li>
</ul>

<p>
my main goal here is to ensure the fact that there is no computer system that
somehow associates my identity to my profile in the voting site. in order to
achieve this my idea is to split the registration into two steps done at a
different time by different organizations.
</p>

<p>
for simplicity let&apos;s assume the registration part happens in january (no voting
during that time) and voting happens during the rest of the year, from february
until december.
</p>

<p>
in january the first organization checks my identity and then it records this
fact into their database. this registration fails if i am already in the
database. the only thing the database records is the unique identifier on my id
card (e.g. social security number). then as a proof they (or some other trusted
organization) issue me a ticket which is a pair of public and private keys which
i can use as a proof that i correctly proved my identity. the ticket&apos;s public
key goes into a separate database so that the ticket is not linked to my id
number. the organization throws ticket&apos;s private key away, only the voter keeps
it.
</p>

<p>
on the 1st of february this organization would release the list of people who
registered for voting and the list of public keys of the tickets the system
generated. the two lists are not connected but they should have the same number
of elements. this way people could check who registered for voting and also
ensure that there are no invalid tickets maliciously generated (or if there are,
it&apos;s obvious). though the only way to audit the lack of invalid registrations
would be to confirm with every registered voter that they indeed registered.
independent auditors can probably use some statistical methods to estimate the
number of invalid registrations.
</p>

<p>
the second organization is the one that runs the voting site. in order to
register here you need a valid ticket from the first organization. you need the
private key for the registration and one ticket gives one registration only.
this way no person can register as another person unless they stole their
private key but in that case the former person cannot register. again, this
error is detectable even if not correctible. this system also does not collect
anything other than a (perhaps randomly generated) username and password. no
email address even to avoid the possibility of linking data after a leak (again:
users should use separate sites to keep informed about what is going on; i am
imagining an infrastructure service, not a social networking site). even the
ticket&apos;s public key is not linked to a specific user other than marked as used
in a separate table.
</p>

<p>
the registration is valid only for a year. people will lose passwords or have
their accounts hacked. since the system itself does not link accounts to the
real people, those accounts will be lost until their expiration. this would be
the cost of people not being careful with their password (a sort of perverse
democratic darwin award). however the damage is only temporary because next year
people can re-register.
</p>

<p>
the other problem is accountability of the votes. i think the solution for that
is just public dumps of the actual votes. after each vote the system releases a
big file that contains a row with 2 elements: random unique number identifying
the voter and the actual votes (the delegation chain would not be public, the
system resolves those automatically, only the final votes remain). the unique id
for the voters would change after each vote so that it is impossible for anyone
to track voters over time yet each voter can independently verify that their
vote is in the official dump.
</p>

<p>
and that would be the gist of it. obviously as it stands there are a lot of
rough edges that need careful thought. it does not rely on any wasteful
blockchain crap though. sure, it requires a trusted central authority running
this but as long as that authority is transparent, i do not see a problem with
this. if a society cannot arrange this, then no amount of blockchain technology
can save it. if it can then the blockchain tech is not really needed.
</p>

<p>
i can see a bunch of parties starting up. the only sad part of it that although
most of them embrace blockchain as the savior of earth, they do not care much
about anonymity. or at least they are not doing good job explaining why they ask
for my name and other data and how can i be sure that it will never leak away:
linking my votes and my identity. not that i particularly care about my votes
being public or not, i just want to make sure the system gets this aspect right.
i will look out for stuff like and see how it goes.
</p>

<p>
by the way, speaking of blockchain. one of my annoyances with blockchains is
that they unnecessarily burn lot of computation away. it&apos;s wasteful. i&apos;m using a
fully central solution here. i think that&apos;s a fair tradeoff in exchange for
greater efficiency. the whole system i&apos;m describing here could run on a single
raspberry pi even for multi-million users. usually centralization happens for
saving resources. i don&apos;t have much qualms about this as long as centralized
component&apos;s scope and features are very limited.
</p>

<p>
and the actual decisionmaking might slow down, one won&apos;t be able to make
unpopular things into law since people won&apos;t vote on it. i think that&apos;s fair
compromise. if someone wants to make an unpopular change affecting the whole
population, i think it&apos;s fair that they should first convince the whole
population to want it rather than forcing it down their throat (as opposed to
convincing only a few politicians). or maybe try to convince smaller communities
to willingly canary some changes and if only try for the global change if the
canary was successful. in any case, it might not be perfect, but i think it
would make people more interested in the whole political process.
</p>

<h2 id="fsbuf">fsbuf</h2>
<p>
i&apos;m thinking of keeping my filesystems mounted read only on some of my linux
computers. i sometimes do stupid stuff and not touching disk by default sounds
like a sensible way to prevent accidents. what i would prefer instead is that
the operating system keeps my changes in memory and then i can review them and
once happy, commit them to disk. this mode also ensures that my disks are always
in a cleanly unmounted state, i can just simply turn off or restart the computer
anytime without bothering with proper shutdown procedures. i&apos;m not fully
confident that i want this because it also means that i&apos;m now forcing myself to
do an additional manual sync after each piece of work. but at least i want to
know how to do it. i haven&apos;t found any good tutorial on the internet so i
thought i&apos;ll write down my findings for my own future reference.
</p>

<p>
note that i am aware that i could just use git for everything, and perhaps copy
the whole homedir to a tmpfs and then just copy back the commited files. that&apos;s
one way, but i&apos;m wondering if it&apos;s possible to solve this problem in a more
general and transparent way.
</p>

<p>
by the way, that wouldn&apos;t be the only usecase you would consider this for. maybe
you want to continue using your disk as is, but occasionally you want to make
send the changes over to a slower, backup storage. there are probably some
better solutions for this, but the solution described here would work with any
underlying filesystem without too much of a hassle and performance loss.
</p>

<p>
i&apos;ll use unionfs-fuse for this. don&apos;t confuse that with unionfs which is a
kernel module implementing the same thing, and don&apos;t confuse it with overlayfs
either which is another newer and fancier kernel module implementing similar
things. only unionfs-fuse allows modifying the underlying filesystems directly
without breaking its internal structures so it&apos;s the only system i can do online
merging without too much of a fuss. sure, there are some caveats and edge cases
where it wouldn&apos;t work, but i&apos;m pretty sure that&apos;s rare enough to not bother
caring. and i&apos;ll call unionfs-fuse as unionfs from now on for simplicy.
</p>

<p>
and for example&apos;s simplicity let&apos;s suppose the following directory structure:
</p>

<ul><li>
  /home: the home directory i&apos;ll be working day to day. this is the directory
  unionfs will create.
</li><li>
  /homedisk: the disk backend of the /home directory. this is the read-only
  branch for unionfs.
</li><li>
  /homebufrw: this will be a tmpfs dir containing files that i haven&apos;t committed
  to the disk yet. this will be always mounted as read-write. it needs to be
  read-write because during the sync operation the sync script will move the
  files to /homedisk and then delete them from /homebufrw.
</li><li>
  /homebuf:  this will be the read-write branch for unionfs. it is a bind mount
  for /homebufrw that we can toggle into read-only mode during syncs so that
  nothing can alter the /home filesystem during a sync operation to avoid race
  conditions. the read-only switch is not necessarily needed, but i&apos;d prefer it
  that way to ensure nothing can break my sync scripts.
</li>
</ul>

<p>
also note that most commands here assume root as runner. it is possible to avoid
using root for most mount commands using clever /etc/fstab config but that&apos;s a
bit outside the scope of this tutorial so i&apos;ll leave it out.
</p>

<p>
make sure all 4 directories exist:
</p>

<pre>
  dirs=&quot;/home /homedisk /homebuf /homebufrw&quot;
  mkdir $dirs
  chown 1000:100 $dirs
</pre>

<p>
user:gid of 1000:100 usually means the default user and the default users group.
if you already have a /home directory, just rename it to /homedisk instead.
ideally you would set this up when you are not using said home directory. e.g.
you are logged out and setting this up as root, or setting the disk up from a
different system.
</p>

<p>
i&apos;ll assume /homedisk is already mounted, preferably as read only. it might be
just a vanilla dir on / in which case i&apos;ll assume / is mounted read-only.
</p>

<p>
next, mount a rw tmpfs on /homebufrw and bind /homebuf:
</p>

<pre>
  mount -o mode=0755,uid=1000,gid=100 -t tmpfs tmpfs /homebuf
  mount -o bind,rw /homebuf /homebufrw
</pre>

<p>
now, mount the unionfs. run the unionfs command as your own user otherwise you
unionsfs will create its helper files as root and that&apos;s not ideal. you won&apos;t be
able to run setuid binaries from this directory, unfortunately.
</p>

<pre>
  modprobe fuse
  cd /  # to ensure we can unmount /home no matter where we ran the command.
  # note at this point / must be mounted as read-write in order to mount fuse.
  unionfs -o allow_other,cow,hide_meta_files /homebuf=RW:/homedisk=RO /home
</pre>

<p>
you should now see the contents of /homedisk under /home. feel free to make
changes to /home. all the changes will be persisted in /homebuf.
</p>

<p>
now comes the interesthing part: how to commit changes from /homebuf to
/homedisk? first, as a matter of good hygiene, remount /homebuf as read only
(and for some reason this remount propagates to /homebufrw too so mount that
back as rw which then doesn&apos;t propagate back):
</p>

<pre>
  mount -o remount,ro /homebuf
  mount -o remount,rw /homebufrw
</pre>

<p>
you can only do this if there are no open writers. you list the writers like
this:
</p>

<pre>
  fuser -vMm /home 2&gt;&amp;1 | grep F
</pre>

<p>
if you are very careful, you could do the merge even if you keep /homebuf open
for writing as long as you avoid deleting the files it has open for writing. i
won&apos;t support this case though in my usync utility.
</p>

<p>
next, remount /homedisk or / as read-write:
</p>

<pre>
  mount -o remount,rw /homedisk
</pre>

<p>
now all you need to do is to move the contents from /homebufrw to /homedisk. i
wrote a small script for this called usync (see /usync.sh). run that.
</p>

<pre>
  usync /homebufrw /homedisk
</pre>

<p>
after that&apos;s done, you can simply restore the mounts and continue editing /home:
</p>

<pre>
  mount -o remount,ro /homedisk
  mount -o remount,rw /homebuf
</pre>

<p>
and that&apos;s all to it.
</p>

<p>
to make things even more convenient for myself, i made the following &quot;bsync&quot;
script for myself:
</p>

<pre>
  #!/bin/bash
  set -ex
  wmount disk
  usync /homebufrw /homedisk
  wmount buf
</pre>

<p>
wmount (see /wmount.c) a setuid script that lets me switch between rw mounting
either the disk or the buffer but not both. the point is that my disk is mounted
rw only during running the bsync command. and i also see what files changed
since the last sync.
</p>

<p>
there&apos;s one annoyance with the current set of scripts though: they don&apos;t handle
fuse&apos;s interpretation of deleted but still open files well. fuse handles such
deletion via a simple rename. it renames a deleted file into &quot;.fuse_hiddenXXX&quot;
file. this shouldn&apos;t be sync&apos;d to backing store and it also means that after a
sync, i cannot delete everything from /homebufrw. however this is not super
common scenario so my usync tries to detect this and bails out if it&apos;s the case.
it also prints out which processes are keeping such files open. in such cases
it&apos;s up to the user to make the tasks release their open file descriptors.
</p>

<p>
in any case, i&apos;m using this setup for a few days now and it seems to be working
well. it&apos;s a bit annoying way to use a computer but it definitely works.
</p>

<p>
edit: oops, looks like unionfs-fuse still has some rough edges. i found a bug in
it: https://github.com/rpodgorny/unionfs-fuse/issues/91.
</p>

<h2 id="codeswap">codeswap</h2>
<p>
i am really curious how effective my &quot;avoid creating types&quot; approach would be
compared to the object oriented approach. i am thinking of creating an
experiment for it. not that i would ever conduct such an experiment but thinking
about it is fun. i am not even sure where would i get people for this experiment
but suppose that problem is solved. now imagine i have a room full workstations
next to each other like in a typical open plan office. the experiment would
involve having the participants solve a series of related programming challenges
on these machines under a time constraint. then they would need to swap their
solutions and continue working on other people&apos;s code. the swap also changes the
problem the participants are supposed to solve. there are two problems, the swap
is done a way that it changes the problem for everyone. to make sure there is no
language barrier, i would ask each participant to use the same language.
something simple, e.g. c, go or python. i would ask the participants to brush up
their language skills before coming to my test. i would also make the
environment equally bad for each participant so that the environment has very
little effect on the results. to be specific: all i would give them is just a
terminal that is split into two windows: left side runs the nano text editor,
right side runs a terminal app that shows how correct their solution is. every
time they hit save in nano, it updates the right hand side with the results. i
would split the experiment itself into the following phases:
</p>

<ul><li>
  intro phase: give participants their problems and have them read a
  motivational text how to approach the problems.
</li><li>
  design phase (30m): the participants can write code but they get no feedback
  on the right hand side yet. they are supposed to architect their solution
  during this time. nearing the end they are also expected to write a feedback
  how hard they thought the problem was or their general thoughts about the
  experiment. they can just write this feedback directly into their source code
  as free form text at the bottom, i will strip this out before compiling or
  swapping the code.
</li><li>
  implementation phase (30m): at this point the right hand window wakes up and
  starts giving feedback. if they worked well, the participants should be able
  to easily make their code compile and solve the subproblems correctly (the
  ones they have already implemented) and then just continue solving more
  subproblems. nearing the end they are expected to give feedback to the study
  at this point too. however at this point they should also leave some pointers
  what was done and what the next steps are for implementing more features. this
  should be aimed at the next person.
</li><li>
  continuation phase (60m): now the system swaps around the code. the students
  have to work with other people&apos;s code. they have to get familiar with it and
  continue working on implementing the missing features. the swapping phase also
  changes the problem so the students also need to get familiar with a different
  problem. nearing the end they should write more feedback.
</li>
</ul>

<p>
i am not sure how to implement the swapping phase yet: i can either ask the
participants to swap desks, or i can make the computers shuffle the code around.
either one works. if the latter, i need to be careful to prevent participants
from saving utility functions somewhere for reuse. they should completely lose
everything they have written so far.
</p>

<p>
the two problems would be very similar when reduced to the core but they would
be phrased differently and put into different context so that it is not obvious
that it is the same thing. but at the same time the two problems must be
different enough so that the participant cannot just simply delete everything
and rewrite stuff from memory.
</p>

<p>
the motivational text would have 2 dimensions, totaling in 4 different texts:
</p>

<ul><li>
  one half says that having comments is an indicator of poor code, participants
  should design their code in a way that does not require comments. the other
  half says that comments really humanize the code, people should write a lot of
  comments to make the intent clear.
</li><li>
  in the other dimension one half says that abstraction is what keeps the code
  simple and straightforward. make the structure of the code similar to the
  structure of the problem. the other half suggests to avoid abstraction: try
  avoiding creating new types, try sticking to arrays and long functions.
</li>
</ul>

<p>
after the experiment is done, i would ask them to fill a survey. for each phase
it would ask the following binary questions:
</p>

<ul><li>
  was it clear what you needed to do?
</li><li>
  did you find this task fun?
</li><li>
  did you feel productive?
</li><li>
  was it easy to work with the code?
</li><li>
  did complexity unnecessarily hindered you?
</li><li>
  do you feel you could have achieved more in a better environment?
</li>
</ul>

<p>
my hunch is that in the design/impl phase the nocomments+abstraction group will
feel the most fun, ease and productivity but the comments+noabstraction group
will get more stuff done. in the continuation phase:
</p>

<ul><li>
  nocomments+abstraction continues on nocomments+abstraction code: not fun,
  hard, unproductive.
</li><li>
  nocomments+abstraction continue on comments+noabstraction code: not fun, easy,
  productive.
</li><li>
  comments+noabstraction continue on nocomments+abstraction code: not fun, hard,
  unproductive.
</li><li>
  comments+noabstraction continue on comments+noabstraction code: not fun, easy,
  productive.
</li>
</ul>

<p>
in other words: the continuation phase is not fun since people do not really
like to work on other people&apos;s code. working on non-abstract code will be much
easier and people will feel more productive afterwards. the
&quot;comment+noabstraction continues on comments+noabstractions&quot; group will have an
advantage though: if they followed the recommendation, they should have come up
with roughly the same structure so they should be more familiar with the new
codebase.
</p>

<p>
and if it turns out that is the case then i will be vindicated. most software is
just a different configuration of the same underlying concepts. there is no need
to abstract away all this but rather what is needed is learning to recognize
patterns. the professional chess example is very apt: pro chess players can
instantly recognize very complex state in the middle of a pro match. even though
they might even give some states a name (an abstraction), it is not the name
that helps them recognize the state but rather the fact that they worked with so
many different chess states so long. it is the experience that matters rather
than ensuring every little concept has its own name. in fact, take two random
pro chess players: if they talk different languages they will not be able to
talk with each other much. but show both of them the same chess board and it is
very likely that both of them will make the same next step. this next step is
obvious from the abstraction-free chessboard. yet if they cannot see the
chessboard, they will pretty much not be able to agree what should be the next
step solely because they do not know what the other person is talking about.
</p>

<p>
when working with code, all we can do is to project the code&apos;s concepts into
concepts we already know. for instance as part of my sysadmin work i often
project the software into the realm of linux system calls. i am very familiar
with those and as long as i can understand the code in terms of syscalls, i can
pretty much have a rough idea what it is trying to achieve and how. a code feels
complex when i cannot do this projection. so my recommendation is to stay on
this level, avoid creating concepts that have unclear projections onto the well
known concepts. and i am not saying to completely avoid creating new concepts.
rather only create a new concept if you have a handful of usecases (at least
three): then i can see the concept from various angles and i can learn why is it
an useful concept. otherwise it is just a like a useless signpost saying &quot;this
is a signpost&quot;.
</p>

<p>
anyways.
</p>

<p>
as for the problem: i am not sure about this yet. it needs a theme and a bunch
of small and easy problems related to that theme so the participants can solve
some of them. maybe something like this: you are managing a garden. your task is
to read the garden description and help the farmers answer a few questions:
</p>

<ul><li>
  what is the area of the garden?
</li><li>
  how many types of vegetables are there?
</li><li>
  which vegetable consumes the most area?
</li><li>
  can you render a map of the garden? (just on the console, not a picture)
</li><li>
  given the work needed for each vegetable, how much work does the farm need?
</li><li>
  how expensive is the garden to maintain?
</li><li>
  how much money can the farmer make of the garden?
</li><li>
  suggest a better, more money making plantation for next year.
</li><li>
  which two plantations are the furthest away?
</li><li>
  and a very hard one for the ultra productive people so that they do not get
  bored: can you draw a road network to connect the plantations? make sure
  everything is easily reachable but at the same time try to minimize the number
  of road cells you need.
</li>
</ul>

<p>
obviously i need to think more about this part but that is the rough idea. the
other problem could be very similar but it would be zoo themed. you would have
animals and zookeepers instead. or maybe school themed where you would have
teachers, students and grades. dunno, this is just an implementation detail.
</p>

<p>
thinking about this even gives me an idea on how to approach learning the ways
of software development if you have access to a buddy: both should start a
project each but nearing the end have the other person finish it. iterate this
(while occassionally changing buddies) until you feel confident in coding. every
time you do a swap, there is a lot of context that needs exchanging. but if you
do this often enough, over time it will be clear what sort of documentation or
coding styles you need to write or use to make your code easy to pick up. i wish
more people would be better experienced in this area of software development. oh
well. might be a silly idea but still interesting to me.
</p>

<p>
maybe if i were a university professor with lots of time on his hand, i could
conduct such experiments on my students. hmm.
</p>
</body></html>
