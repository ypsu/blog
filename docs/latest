<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>notech.ie</title>
</head><body>
<h1>notech.ie</h1>
<ul>
<li><a href="#fsbuf">/fsbuf</a> are my notes about filesystem buffering.</li>
<li><a href="#codeswap">/codeswap</a> describes how would i compare software design styles.</li>
<li><a href="#complexity">/complexity</a> in software can be avoided.</li>
<li><a href="#pain">/pain</a> is something to embrace.</li>
</ul>

<h2 id="fsbuf">fsbuf</h2>
<p>
i&apos;m thinking of keeping my filesystems mounted read only on some of my linux
computers. i sometimes do stupid stuff and not touching disk by default sounds
like a sensible way to prevent accidents. what i would prefer instead is that
the operating system keeps my changes in memory and then i can review them and
once happy, commit them to disk. this mode also ensures that my disks are always
in a cleanly unmounted state, i can just simply turn off or restart the computer
anytime without bothering with proper shutdown procedures. i&apos;m not fully
confident that i want this because it also means that i&apos;m now forcing myself to
do an additional manual sync after each piece of work. but at least i want to
know how to do it. i haven&apos;t found any good tutorial on the internet so i
thought i&apos;ll write down my findings for my own future reference.
</p>

<p>
note that i am aware that i could just use git for everything, and perhaps copy
the whole homedir to a tmpfs and then just copy back the commited files. that&apos;s
one way, but i&apos;m wondering if it&apos;s possible to solve this problem in a more
general and transparent way.
</p>

<p>
by the way, that wouldn&apos;t be the only usecase you would consider this for. maybe
you want to continue using your disk as is, but occasionally you want to make
send the changes over to a slower, backup storage. there are probably some
better solutions for this, but the solution described here would work with any
underlying filesystem without too much of a hassle and performance loss.
</p>

<p>
i&apos;ll use unionfs-fuse for this. don&apos;t confuse that with unionfs which is a
kernel module implementing the same thing, and don&apos;t confuse it with overlayfs
either which is another newer and fancier kernel module implementing similar
things. only unionfs-fuse allows modifying the underlying filesystems directly
without breaking its internal structures so it&apos;s the only system i can do online
merging without too much of a fuss. sure, there are some caveats and edge cases
where it wouldn&apos;t work, but i&apos;m pretty sure that&apos;s rare enough to not bother
caring. and i&apos;ll call unionfs-fuse as unionfs from now on for simplicy.
</p>

<p>
and for example&apos;s simplicity let&apos;s suppose the following directory structure:
</p>

<ul><li>
  /home: the home directory i&apos;ll be working day to day. this is the directory
  unionfs will create.
</li><li>
  /homedisk: the disk backend of the /home directory. this is the read-only
  branch for unionfs.
</li><li>
  /homebufrw: this will be a tmpfs dir containing files that i haven&apos;t committed
  to the disk yet. this will be always mounted as read-write. it needs to be
  read-write because during the sync operation the sync script will move the
  files to /homedisk and then delete them from /homebufrw.
</li><li>
  /homebuf:  this will be the read-write branch for unionfs. it is a bind mount
  for /homebufrw that we can toggle into read-only mode during syncs so that
  nothing can alter the /home filesystem during a sync operation to avoid race
  conditions. the read-only switch is not necessarily needed, but i&apos;d prefer it
  that way to ensure nothing can break my sync scripts.
</li>
</ul>

<p>
also note that most commands here assume root as runner. it is possible to avoid
using root for most mount commands using clever /etc/fstab config but that&apos;s a
bit outside the scope of this tutorial so i&apos;ll leave it out.
</p>

<p>
make sure all 4 directories exist:
</p>

<pre>
  dirs=&quot;/home /homedisk /homebuf /homebufrw&quot;
  mkdir $dirs
  chown 1000:100 $dirs
</pre>

<p>
user:gid of 1000:100 usually means the default user and the default users group.
if you already have a /home directory, just rename it to /homedisk instead.
ideally you would set this up when you are not using said home directory. e.g.
you are logged out and setting this up as root, or setting the disk up from a
different system.
</p>

<p>
i&apos;ll assume /homedisk is already mounted, preferably as read only. it might be
just a vanilla dir on / in which case i&apos;ll assume / is mounted read-only.
</p>

<p>
next, mount a rw tmpfs on /homebufrw and bind /homebuf:
</p>

<pre>
  mount -o mode=0755,uid=1000,gid=100 -t tmpfs tmpfs /homebuf
  mount -o bind,rw /homebufrw /homebuf
</pre>

<p>
now, mount the unionfs. run the unionfs command as your own user otherwise you
unionsfs will create its helper files as root and that&apos;s not ideal. you won&apos;t be
able to run setuid binaries from this directory, unfortunately.
</p>

<pre>
  modprobe fuse
  cd /  # to ensure we can unmount /home no matter where we ran the command.
  unionfs -o allow_other,cow,hide_meta_files /homebuf=RW:/homedisk=RO /home
</pre>

<p>
you should now see the contents of /homedisk under /home. feel free to make
changes to /home. all the changes will be persisted in /homebuf.
</p>

<p>
now comes the interesthing part: how to commit changes from /homebuf to
/homedisk? first, as a matter of good hygiene, remount /homebuf as read only
(and for some reason this remount propagates to /homebufrw too so mount that
back as rw which then doesn&apos;t propagate back):
</p>

<pre>
  mount -o remount,ro /homebuf
  mount -o remount,rw /homebufrw
</pre>

<p>
you can only do this if there are no open writers. you list the writers like
this:
</p>

<pre>
  fuser -vMm /home 2&gt;&amp;1 | grep F
</pre>

<p>
if you are very careful, you could do the merge even if you keep /homebuf open
for writing as long as you avoid deleting the files it has open for writing. i
won&apos;t support this case though in my usync utility.
</p>

<p>
next, remount /homedisk or / as read-write:
</p>

<pre>
  mount -o remount,rw /homedisk
</pre>

<p>
now all you need to do is to move the contents from /homebufrw to /homedisk. i
wrote a small script for this called usync (see /usync.sh). run that.
</p>

<pre>
  usync /homebufrw /homedisk
</pre>

<p>
after that&apos;s done, you can simply restore the mounts and continue editing /home:
</p>

<pre>
  mount -o remount,ro /homedisk
  mount -o remount,rw /homebuf
</pre>

<p>
and that&apos;s all to it.
</p>

<p>
to make things even more convenient for myself, i made the following &quot;bsync&quot;
script for myself:
</p>

<pre>
  #!/bin/bash
  set -ex
  wmount disk
  usync /homebufrw /homedisk
  wmount buf
</pre>

<p>
wmount (see /wmount.c) a setuid script that lets me switch between rw mounting
either the disk or the buffer but not both. the point is that my disk is mounted
rw only during running the bsync command. and i also see what files changed
since the last sync.
</p>

<p>
there&apos;s one annoyance with the current set of scripts though: they don&apos;t handle
fuse&apos;s interpretation of deleted files well. fuse handles deletion via a simple
rename. it renames a deleted file into &quot;.fuse_hiddenXXX&quot; file. this shouldn&apos;t be
sync&apos;d to backing store and it also means that after a sync, i cannot delete
everything from /homebufrw. however this is not super common scenario so my
usync tries to detect this and bails out if it&apos;s the case. it also prints out
which processes are keeping such files open. in such cases it&apos;s up to the user
to make the tasks release their open file descriptors.
</p>

<p>
in any case, i&apos;m using this setup for a few days now and it seems to be working
well. it&apos;s a bit annoying way to use a computer but it definitely works.
</p>

<p>
edit: oops, looks like unionfs-fuse still has some rough edges. i found a bug in
it: https://github.com/rpodgorny/unionfs-fuse/issues/91.
</p>

<h2 id="codeswap">codeswap</h2>
<p>
i am really curious how effective my &quot;avoid creating types&quot; approach would be
compared to the object oriented approach. i am thinking of creating an
experiment for it. not that i would ever conduct such an experiment but thinking
about it is fun. i am not even sure where would i get people for this experiment
but suppose that problem is solved. now imagine i have a room full workstations
next to each other like in a typical open plan office. the experiment would
involve having the participants solve a series of related programming challenges
on these machines under a time constraint. then they would need to swap their
solutions and continue working on other people&apos;s code. the swap also changes the
problem the participants are supposed to solve. there are two problems, the swap
is done a way that it changes the problem for everyone. to make sure there is no
language barrier, i would ask each participant to use the same language.
something simple, e.g. c, go or python. i would ask the participants to brush up
their language skills before coming to my test. i would also make the
environment equally bad for each participant so that the environment has very
little effect on the results. to be specific: all i would give them is just a
terminal that is split into two windows: left side runs the nano text editor,
right side runs a terminal app that shows how correct their solution is. every
time they hit save in nano, it updates the right hand side with the results. i
would split the experiment itself into the following phases:
</p>

<ul><li>
  intro phase: give participants their problems and have them read a
  motivational text how to approach the problems.
</li><li>
  design phase (30m): the participants can write code but they get no feedback
  on the right hand side yet. they are supposed to architect their solution
  during this time. nearing the end they are also expected to write a feedback
  how hard they thought the problem was or their general thoughts about the
  experiment. they can just write this feedback directly into their source code
  as free form text at the bottom, i will strip this out before compiling or
  swapping the code.
</li><li>
  implementation phase (30m): at this point the right hand window wakes up and
  starts giving feedback. if they worked well, the participants should be able
  to easily make their code compile and solve the subproblems correctly (the
  ones they have already implemented) and then just continue solving more
  subproblems. nearing the end they are expected to give feedback to the study
  at this point too. however at this point they should also leave some pointers
  what was done and what the next steps are for implementing more features. this
  should be aimed at the next person.
</li><li>
  continuation phase (60m): now the system swaps around the code. the students
  have to work with other people&apos;s code. they have to get familiar with it and
  continue working on implementing the missing features. the swapping phase also
  changes the problem so the students also need to get familiar with a different
  problem. nearing the end they should write more feedback.
</li>
</ul>

<p>
i am not sure how to implement the swapping phase yet: i can either ask the
participants to swap desks, or i can make the computers shuffle the code around.
either one works. if the latter, i need to be careful to prevent participants
from saving utility functions somewhere for reuse. they should completely lose
everything they have written so far.
</p>

<p>
the two problems would be very similar when reduced to the core but they would
be phrased differently and put into different context so that it is not obvious
that it is the same thing. but at the same time the two problems must be
different enough so that the participant cannot just simply delete everything
and rewrite stuff from memory.
</p>

<p>
the motivational text would have 2 dimensions, totaling in 4 different texts:
</p>

<ul><li>
  one half says that having comments is an indicator of poor code, participants
  should design their code in a way that does not require comments. the other
  half says that comments really humanize the code, people should write a lot of
  comments to make the intent clear.
</li><li>
  in the other dimension one half says that abstraction is what keeps the code
  simple and straightforward. make the structure of the code similar to the
  structure of the problem. the other half suggests to avoid abstraction: try
  avoiding creating new types, try sticking to arrays and long functions.
</li>
</ul>

<p>
after the experiment is done, i would ask them to fill a survey. for each phase
it would ask the following binary questions:
</p>

<ul><li>
  was it clear what you needed to do?
</li><li>
  did you find this task fun?
</li><li>
  did you feel productive?
</li><li>
  was it easy to work with the code?
</li><li>
  did complexity unnecessarily hindered you?
</li><li>
  do you feel you could have achieved more in a better environment?
</li>
</ul>

<p>
my hunch is that in the design/impl phase the nocomments+abstraction group will
feel the most fun, ease and productivity but the comments+noabstraction group
will get more stuff done. in the continuation phase:
</p>

<ul><li>
  nocomments+abstraction continues on nocomments+abstraction code: not fun,
  hard, unproductive.
</li><li>
  nocomments+abstraction continue on comments+noabstraction code: not fun, easy,
  productive.
</li><li>
  comments+noabstraction continue on nocomments+abstraction code: not fun, hard,
  unproductive.
</li><li>
  comments+noabstraction continue on comments+noabstraction code: not fun, easy,
  productive.
</li>
</ul>

<p>
in other words: the continuation phase is not fun since people do not really
like to work on other people&apos;s code. working on non-abstract code will be much
easier and people will feel more productive afterwards. the
&quot;comment+noabstraction continues on comments+noabstractions&quot; group will have an
advantage though: if they followed the recommendation, they should have come up
with roughly the same structure so they should be more familiar with the new
codebase.
</p>

<p>
and if it turns out that is the case then i will be vindicated. most software is
just a different configuration of the same underlying concepts. there is no need
to abstract away all this but rather what is needed is learning to recognize
patterns. the professional chess example is very apt: pro chess players can
instantly recognize very complex state in the middle of a pro match. even though
they might even give some states a name (an abstraction), it is not the name
that helps them recognize the state but rather the fact that they worked with so
many different chess states so long. it is the experience that matters rather
than ensuring every little concept has its own name. in fact, take two random
pro chess players: if they talk different languages they will not be able to
talk with each other much. but show both of them the same chess board and it is
very likely that both of them will make the same next step. this next step is
obvious from the abstraction-free chessboard. yet if they cannot see the
chessboard, they will pretty much not be able to agree what should be the next
step solely because they do not know what the other person is talking about.
</p>

<p>
when working with code, all we can do is to project the code&apos;s concepts into
concepts we already know. for instance as part of my sysadmin work i often
project the software into the realm of linux system calls. i am very familiar
with those and as long as i can understand the code in terms of syscalls, i can
pretty much have a rough idea what it is trying to achieve and how. a code feels
complex when i cannot do this projection. so my recommendation is to stay on
this level, avoid creating concepts that have unclear projections onto the well
known concepts. and i am not saying to completely avoid creating new concepts.
rather only create a new concept if you have a handful of usecases (at least
three): then i can see the concept from various angles and i can learn why is it
an useful concept. otherwise it is just a like a useless signpost saying &quot;this
is a signpost&quot;.
</p>

<p>
anyways.
</p>

<p>
as for the problem: i am not sure about this yet. it needs a theme and a bunch
of small and easy problems related to that theme so the participants can solve
some of them. maybe something like this: you are managing a garden. your task is
to read the garden description and help the farmers answer a few questions:
</p>

<ul><li>
  what is the area of the garden?
</li><li>
  how many types of vegetables are there?
</li><li>
  which vegetable consumes the most area?
</li><li>
  can you render a map of the garden? (just on the console, not a picture)
</li><li>
  given the work needed for each vegetable, how much work does the farm need?
</li><li>
  how expensive is the garden to maintain?
</li><li>
  how much money can the farmer make of the garden?
</li><li>
  suggest a better, more money making plantation for next year.
</li><li>
  which two plantations are the furthest away?
</li><li>
  and a very hard one for the ultra productive people so that they do not get
  bored: can you draw a road network to connect the plantations? make sure
  everything is easily reachable but at the same time try to minimize the number
  of road cells you need.
</li>
</ul>

<p>
obviously i need to think more about this part but that is the rough idea. the
other problem could be very similar but it would be zoo themed. you would have
animals and zookeepers instead. or maybe school themed where you would have
teachers, students and grades. dunno, this is just an implementation detail.
</p>

<p>
thinking about this even gives me an idea on how to approach learning the ways
of software development if you have access to a buddy: both should start a
project each but nearing the end have the other person finish it. iterate this
(while occassionally changing buddies) until you feel confident in coding. every
time you do a swap, there is a lot of context that needs exchanging. but if you
do this often enough, over time it will be clear what sort of documentation or
coding styles you need to write or use to make your code easy to pick up. i wish
more people would be better experienced in this area of software development. oh
well. might be a silly idea but still interesting to me.
</p>

<p>
maybe if i were a university professor with lots of time on his hand, i could
conduct such experiments on my students. hmm.
</p>

<h2 id="complexity">complexity</h2>
<p>
everybody hates complexity. yet at the same time msdp (&quot;modern software
development practices&quot;):
</p>

<ul><li>
  encourage adding complexity under the disguise of reducing complexity.
</li><li>
  discourage people from gaining the expertise to avoid complexity.
</li>
</ul>

<p>
it is not done purposefully. complexity is painful. people do not want to
experience pain. so as long as people do not feel pain things are good. msdp are
like painkillers. they definitely do help not feeling the pain of complexity, no
argument there. but just because people do not feel it, it does not mean it is
not there. eventually people get so much painkiller into their system that they
cannot live without it anymore. and the eventual consequence of all this is
mental breakdown or burnout.
</p>

<p>
all software is a solution to a problem rather than an end in itself. what is a
&quot;problem&quot;? problem is a pair of states: input state and output state. there are
many sorts of problems:
</p>

<ul><li>
  i have a list of numbers -&gt; i have the average of those.
</li><li>
  i have an essay in a text file -&gt; i have the most common word of the essay.
</li><li>
  i time to kill -&gt; i am watching a video.
</li><li>
  i want to pay for the pizza -&gt; the pizzeria has my money.
</li><li>
  i am craving sugar -&gt; i have ice cream in my hand.
</li>
</ul>

<p>
software is that tiny &quot;-&gt;&quot; bit between the two states. in fact, the software
part is completely irrelevant! yet for complexity reduction msdp focus on that
tiny irrelevant part. this is what happens when people consider the software as
an end in itself. the focus should be on the problems instead.
</p>

<p>
take the first problem. it is quite abstract but for a programmer it is super
clear what it means. one can even mentally fill how the software works because
it is just that obvious. now take the last problem. it is very fuzzy and
subjective. it is unclear what the software will be between them. do we create
an online shop where people enter their feelings and we send the appropriate
item for said feeling? or do we create a software for mixing ice cream based on
how much sugar the human wants? it is super unclear what are we trying to solve
here. usually this fact does not stop people from firing up their editor and
start furiously developing stuff.
</p>

<p>
what is the difference between the two problems? the first one expresses a
problem via well known computer science terms: numbers, strings, lists. the last
problem expresses it via abstract terms that try to clearly identify the
concepts in question.
</p>

<p>
why is the software trivial in the first case, complex in the latter? in the
first case the two states are very objective. everybody agrees on what the two
states mean and can reliably tell what and what not matches those descriptions.
as such when people think how to solve the problem, they pretty much arrive at
the same solution so there are not many creative differences in its software
development process. in the latter case people cannot fully agree what
&quot;craving&quot;, &quot;ice cream&quot; or &quot;in my hand&quot; means. every person will have a different
understanding. they will have different assumptions. they will want to implement
different things. and in the middle of the development process they realize that
one team meant something completely different for &quot;in my hand&quot; than the other
team and now they are creating even more problems and software to bridge this
misunderstanding.
</p>

<p>
what is the solution? the job of the software engineer is to reduce the
subjective states into the objective realm of numbers, strings and lists.
</p>

<p>
what does msdp recommend? numbers, strings and lists are unintuitive and hard,
we should abstract and create new terms. instead of &quot;list of numbers&quot; you have
&quot;grades&quot; of &quot;students&quot;. instead of &quot;average&quot; you have &quot;grade average&quot;. when you
define things like this, they start getting muddy. what is a grade? is it a
number? is it a letter? what is the grade average of &quot;a a a b&quot;? the more
abstract terms one introduces, the more muddy the problem and its software will
be. this is what i meant under &quot;msdp encourage adding complexity&quot;.
</p>

<p>
and to top it off, all the tooling msdp create are further exacerbate the
problem. it is all about object orientation, genericity and even type hiding so
that you have even less chance to understand what is going on. people are having
harder and harder time to communicate with each other just because of the sheer
amount of unclear concepts one has to hold in their head.
</p>

<p>
following this practice leads to very very long problem descriptions with many
many types of lists, strings and numbers for the various aspects of the problem.
yes. but the key observation here is that if you write all this out, then you
will see the problem&apos;s essential complexity in its natural form. it will be
ugly. it will be painful. but just because something is ugly or painful, does
not mean you should hide it. what you need to do is to learn to not mind that
ugliness. keep working with it and over time you will gain all the necessary
experience to spot and mentally chunk patterns just like professional chess
players can take a quick look at a chessboard and instantly understand the full
state (and if not then they know that things are messy and should be cleaned
up). if you are a doctor then it would be a quite weird if you would be
uncomfortable looking at dicks. no, instead the expectation would be that you
learn a lot about dicks so that you can look at any dick without problems
because that is the human body in its natural form. yet msdp recommend that you
do your best to hide all those dicks so that nobody gets uncomfortable. the
developer novices do not even have the chance to learn to recognize patterns.
they must work with new abstractions all the time. and if they break down
something too much, they are scolded that they are not following msdp. this is
what i meant by &quot;msdp discourage people from gaining expertise&quot;.
</p>

<p>
the next important task after breaking down the problem into numbers, strings
and lists is to document the mapping between the subjective and the objective
representations of the problem. even though msdp recommend doing this with all
that object oriented madness, this cannot be done formally. the only way to do
this is by writing informal prose. the writer of such mapping must meticulously
explain what each number and list represent in the subjective world. in other
words a software developer&apos;s task is not really to write software but to write
text!
</p>

<p>
this is no easy task. and why would people bother writing documentation anyways.
all the structure is super clear in their mind so the mapping between the
subjective and objective world should be super clear to everyone else too.
interestingly when most developers look back to their own code written in the
past, they think it is ugly and unnecessarily complex. in such cases the
assumption is that this is because they got smarter but that is not the case.
they would write the same code today too. the only thing they are lacking is the
context of their code. and the reason they lack it is because they did not
clearly document the input and output in simple terms. the other characteristic
of most developers is the feeling that they should refactor all the time. they
write something and they are very proud of it. then they try to actually extend
it they realize that what they wrote is not any good and they want to start from
scratch. they constantly want to reimplement things. as such their productivity
is pretty low. if you are thinking in terms of input and output then
understanding code is not hard and you do not get the feeling that your old code
is bad nor do you feel the inclination to refactor all the time.
</p>

<p>
suppose you are using linux every day. you get curious about the kernel. you
want to learn more. you download and open its source code. you barf. it looks
unnecessarily complex and think this is crazy. you even think maybe you should
write a new operating system from scratch just to show them how is it done. see
the problem? this is the &quot;software as an end in itself&quot; approach. if you open a
piece of code and say &quot;i want to understand this&quot; then you are doing it wrong.
</p>

<p>
what you need instead is a problem. you could say &quot;i have all these processes; i
want to know how can they run simultaneously&quot;. if you phrase it like this then
your first step is not to download the linux kernel source code and get
frustrated about its complexity. instead you first open the wikipedia and start
learning about processes. if you know everything about them then you start
learning about the schedulers. once you know about those, you start searching
about linux specific schedulers and you learn how do they work. at no point did
you need to open the linux kernel source to answer your curiosity. but suppose
no one is around to tell you what linux is doing. then you must download and
inspect the code. however in this case you already have the context: you know
the technical terms around both processes and schedulers. you know that you are
looking for a specific thing. you also know that this is a very core thing in an
operating system so &quot;drivers&quot; will not be the right directory. you can pretty
much tell what does and what does not look relevant to this. you find the
corresponding file and it tells you the name of the scheduler and even points to
docs. you got your curiosity satisfied without any complexity getting into your
way. all you really needed is to get accustomed to some objective terms and
concepts and then understand the problem in those terms.
</p>

<p>
software does not exist in vacuum though. it is used in a domain. if the domain
has well specified, objective terms for concepts, then using those when reducing
problems is fine. in the domain of computer system administration i work with
the following concepts:
</p>

<ul><li>
  files: contain all the data.
</li><li>
  processes: calculate all the data.
</li><li>
  rpcs: remote procedure calls for communication.
</li><li>
  machines: run the processes.
</li><li>
  users: isolate or limit the processes.
</li>
</ul>

<p>
if a state is expressed in these terms then i can probably understand it pretty
quickly. it is very easy for me to &quot;visualize&quot; the state in my mind. when i
visualize both the input and output state, i can sort of get a &quot;feel&quot; for what
is happening in between. if i start seeing &quot;tasks&quot;, &quot;channels&quot;, &quot;configs&quot;,
&quot;objects&quot; then things start getting muddy for me. people try to be nice and
&quot;hide the complexity&quot; but all it achieves that i am no longer able to see all
the pieces the software is working with. all i see is fog.
</p>

<p>
it might seem that some problems cannot be reduced to such simple terms. e.g. i
want to write a videogame but i do not really know what exactly the end result
will be since it will require a lot of iterations to get everything right. even
so, you still have a rough idea what you want. in a shooter you want a 3d
environment, players, enemies, weapons. you can break down those concepts into
their corresponding data structures, find some common problems that you are sure
you will encounter (moving around, collision detection), implement those, and
then go from there. the idea is that you should have a clear, objective mapping
between the concepts and their data representation in simple types.
</p>

<p>
another reason people are afraid of deconstructing things into their base forms
is that if they write out the full state like that in such simplistic terms then
it will be way too long and unhelpful. however length should not be an indicator
that you need an abstraction but rather that you need to think more to come up
with a simpler system. sometimes this is impossible: you want efficiency or good
usability and for that you need all those pieces. that is okay. in such case it
will be clear that we are trading simplicity for features. it will be also clear
when are we having way too much features and maybe start thinking in different
terms of approaching the problem.
</p>

<p>
take the case of long functions. msdp suggest that you should break down long
functions if it makes sense. this then reduces the number of local variables you
need and thus you reduce the state the &quot;poor reader&quot; has to keep in head. but
that makes no sense if you consider things from the input output perspective.
you are not reading a function for entertainment. if you are reading a function
then that means you are either trying to extend it or you are trying to find a
bug in it. in both cases what you really need is a good understanding of what
the function does. if all you see is just invocations to other opaque functions
then it will not be clearer what is happening. what you really need is a human
telling you what the function does in high level terms. when you have that
understanding, then you will also have a feeling where to put the missing piece
or where the faulty line might be. where are you going to get this if you do not
see any human around? you will get this from the comments. in other words what
you are really looking for are human comments in functions. and you need good
quality comments. how do you get that?
</p>

<p>
there is this phenomenon in in-person human communication: suppose someone is
explaining something to you. when they finish the explanation, they are looking
at you, waiting for a reaction. if you do not provide any reaction, the other
person will assume that you lost the thread and they will start explaining in
more detail. this also works with code! if you write a large chunk of code then
you will feel bad if you do not give a summary commentary in front of the chunk.
however small chunks feel obvious and as such they are left undocumented. if you
split up a large functions into many small functions, it is pretty much expected
that you will have less documentation and your code will be much harder to
understand.
</p>

<p>
good rule is this: when you see the same logic in 3 places then consider
factoring them into a function but no sooner. below 3 you simply do not know if
the abstraction you are creating is good. 3 and above it means that there is a
common concept hiding there, it might worth naming it. this process is called
semantic compression. note that this process applies when deconstructing state
too: if there are common structures (4 floats representing a vector) then it is
okay to define a structure for them (struct vector). but this structure is just
for naming a common concept, it is not meant to hide its elements or assign
functionality to them like you would do in object oriented programming.
</p>

<p>
since poor functions are one big source of complexity, let me elaborate a bit
further on them. you should treat a long function like you would treat a book.
it should start with an introduction what the function is about, what the inputs
and outputs are and then a table of contents of its logic for quick navigation.
do not use numbers for the sections because the numbers might get invalidated
quickly. make sure the heading names are unique so that the reader can quickly
navigate by text search. this does not really look nice in small examples but as
a quick demo a small example will do:
</p>

<pre>
 // return a solution to a^2*x + b*x + c = 0 (unspecified which one in case of
 // multiple results). x is an output-only variable (must be non-null). the
 // function returns true on success, false in case there is no solution.
 bool solvequadeq(double *x, double a, double b, double c) {
   // solve the equation using the following steps:
   // basecases: handle the base case.
   // discsqrt: calculate the square root of the discriminant.
   // returnres: calculate x and return it.
</pre>

<pre>
   // basecases: handle the base case.
   if (a == 0) {
     *x = -c / b;
     return true;
   }
</pre>

<pre>
   // discsqrt: calculate the square root of the discriminant. this platform
   // lacks sqrt so we implement our own approximation via newton&apos;s method.
   double disc = b * b - 4 * a * c;
   if (disc &lt; 0) return false;
   double discroot = 1;
   for (int i = 0; i &lt; 20; i++) {
     discroot = discroot - ((discroot * discroot) - disc) / (2 * discroot);
   }
</pre>

<pre>
   // returnres: calculate x and return it.
   *x = -b + discroot / (2 * a);
   return true;
 }
</pre>

<p>
as you can see i inlined a sqrt (with the assumption that sqrt() was not
available). sqrt is a pretty well known and understood concept so it would be
okay to grant its own function. but there was nothing of value lost by just
simply inlining it given that it is only used from one place. you could argue
that this way somebody might add another sqrt or that when the platform gets its
sqrt support, nobody will replace this piece of code. now this might be true for
simplistic example, but for a more complicated example somebody would totally
reimplement frobnicate() even if a frobnicate() would have existed already (they
would call it dofrobnicate() so the compiler cannot point out this mistake to
them). and the second concern is not addressed by decomposition either. you will
still have identical pieces of code all around. and even if msdp would address
the issue of duplication, it is a moot point. remember, complexity does not stem
from duplication. complexity stems from the fact the concepts the code works
with are subjective and unclear. obsessing about duplication will not reduce the
complexity.
</p>

<p>
by the way, another trait of msdp is that they always demonstrate their points
using simple examples and for that they all seem convincing. demonstrating
complex examples is cumbersome so they never get to the point where they would
see their systems crumbling down under their own self-inflicted complexity.
</p>

<p>
some comments look superfluous in this small example just like having too many
subheadings in a small book is superfluous. i would not give this many comments
for a function like this. but for longer functions they can really help the
navigation. free form comments are much easier to read than
handle_the_base_case(). from such function name you do not know that it is
related to quadratic equations even.
</p>

<p>
if you squint enough, this is very similar to knuth&apos;s literate programming. the
difference is that in this case we do not generate a separate document for
consumption.
</p>

<p>
what would happen if you started breaking down a long function into short
functions and/or approach the problem in an object oriented programming way? the
essential complexity would still be present, you cannot eliminate that. however
it would add a lot of accidental complexity. you will get bunch of new problems.
you have to pass around state. things will look quite okay initially but it will
be a maintenance and debugging nightmare. when requirements change and you have
to tweak some functionality here and there, you will realize that you need to
pass around even more state. your function prototypes start growing bulky (and
the function names will be obsolete just as well as comments can become
obsolete). eventually you will end up in a codebase where the function splitting
look pretty much arbitrary and does not make any sense. or suppose you want to
speed up the above function. when you look at it like this, it is pretty obvious
that you can trade speed for accuracy just by decreasing the number of
iterations in the loop. you have immediately seen that. had everything been
abstracted away, such observation would have taken quite a while to arrive at.
or suppose you are trying to debug this function. you want to add print
statements here and there to dump state. if all state is available in this
single function, adding such print statements at a few tactical places is super
easy. doing the same in a heavily abstracted code is painful. the point if you
have a lot of abstractions then you spend a lot of time fighting against those
abstractions and this fighting is called the accidental complexity. this is why
all those abstraction fanboys want to refactor their codebase all the time. you
can avoid all this pain just by not abstracting at all until there is a clear,
objective benefit to it (you have at least 3 cases that you can replace with a
single concept).
</p>

<p>
another observation of the whole input output approach is that if the code does
not matter, then the choice of platform and programming language does not matter
much either. this is one of the reasons why c got very popular. it was not
trying push any methodology on people (other than the const correctness
nonsense). it implemented the basic features that people needed for structured
programming and it turned out that was enough for almost everything so it spread
like a virus.
</p>

<p>
this is getting already way too long so let me wrap up. if you disagree
everything written in this post, i ask you this: there are people who manage
complexity like this and it works really well for them. give them some space. do
not disregard their approach completely just because you do not agree. if
something is unclear when approached like this, just ask for better comments.
</p>

<h2 id="pain">pain</h2>
<p>
pain is a signaling system. it signals that something is not right. there are
two types of pain: sudden spike and chronic pain. if you suddenly feel pain then
most of the time something changed around you suddenly and you probably even
know the reason. in this case pain is a useful signal but it can get into the
way of resolving the underlying issue. e.g. if a bear is eating my leg then i
might just give up everything because it is too painful. maybe i would fight or
run more if the missing leg would not be bothering me. so in this case making
the pain go away might be very useful.
</p>

<p>
the chronic pain is different. and by chronic i mean the one that last for very
long time. i do not mean physiological pain only but mental too. inconvenience
might be a better term for the latter. we cannot simply wish the chronic pain
away. so what do we do? we medicate ourselves with painkillers. in the
inconvenience&apos;s case we start using various tools and gadgets to make things
more comfortable. this indeed makes the pain go away so it is a reasonable
solution.
</p>

<p>
however you could look at this differently. pain is something that you are
intrinsically motivated to alleviate. what if rather numbing the pain, you alter
your lifestyle in a way that the pain is manageable? with this approach you do
not feel at mercy of your doctors and drugs anymore. you feel that you are in
charge of life. you start researching your pain. you start experimenting with
things. basically you get a goal and start living. all your actions start to
have a meaning. the &quot;why am i doing this?&quot; feeling is not around. it is not an
easy life. every day you wake up, the pain greets you. it does not allow you to
slack off. you remain passionate about alleviating your pain.
</p>

<p>
and the nice about this is that you can always inflict pain on yourself.
depressed because you are invisible and there is no point in life? start walking
barefoot on the streets. you will immediately notice trash or dog poo on the
ground. you will start moaning how all this trash and dog poo is bad for us all.
you might start picking up the trash in your immediate vicinity in order to make
it habitable for yourself or at least arrange a daily cleaning service on your
street. you start fighting for clean streets. you now matter because you want to
achieve something. and that something is only about fixing your inconvenience:
making sure you can walk around barefoot without getting too dirty.
</p>

<p>
others will think you are crazy. they will try to talk some &quot;sense&quot; into you.
get shoes or else all sorts of bad thinks will happen to you. some people will
even get angry at you. do not let them to get to you or otherwise discourage
you. do not take naysayers seriously. ignore them. you cannot achieve something
without making some people angry. let them have their boring life. yours is now
full of excitement and possibilities. focus on that. after a while you will not
even notice the pain anymore. your body adapted to it naturally. it learned that
this pain might be okay after all and decided to not to bother you anymore. all
you need to survive is the initial period of the pain. do not underestimate your
body&apos;s and mind&apos;s adapting capability.
</p>

<p>
this does not mean that you should go all out and do all sorts of crazy stuff.
it works only up to a point anyways (yerkes-dodson law). and this takes a very
special personality. most people are not up to this. there are two lessons you
can take away: 1. if you ever feel uncomfortable, maybe keep yourself in that
state just a little longer just to see what happens, 2. if you see other people
doing crazy things despite the apparent pain, do not feel superior to them. all
the nice things we have today is thanks to crazy visionaries who went against
the establishment, made a lot of people angry and sometimes even suffered a lot
in exchange. try to understand their motivations instead. try to not obsess
about what and how they are doing things but rather what they are achieving.
after all, do not we all want clean streets?
</p>
</body></html>
